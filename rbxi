#!/bin/bash
########################################################################
####  Script Name: rbxi
####  Version: 2.0.6
####  Date: 18 December 2008
####  Copyright (C) Harald Hope 2006-9
####
####  This program is free software; you can redistribute it and/or modify it under
####  the terms of the GNU General Public License as published by the Free Software
####  Foundation; either version 3 of the License, or (at your option) any later version.
####
####  This program is distributed in the hope that it will be useful, but WITHOUT
####  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
####  FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
####
####  Get the full text of the GPL here: http://www.gnu.org/licenses/gpl.txt
####
####  This is an rdiff-backup/rsync script which helps automate the backup process
####  Requires companion excludes-....txt files to run, those must be in the rbxi-data
####  directory
####
####  rbxi.tar.bz2 package download URL: http://smxi.org/rb [contains all needed files]
####  Script Home page: http://techpatterns.com/forums/about831.html
########################################################################

########################################################################
####  VARIABLES
####  Make sure to change these to fit your installation
########################################################################

########################################################################
####  LAYOUT VARIABLES
####--------------------------------------------------------------------
# colors
W="[1;31;40m" # red: Warning message
E="[1;33;40m" # yellow: script Error
S="[0;39m" # green: Standard message
Q="[1;36;40m" # CYAN: Questions
M="[1;36;40m" # CYAN: Message
# M="[1;34m" # BLUE: Message
C="[1;35;40m" # MAGENTA: Command or Path
B="[40m" # black background
N="[0;39m" # default system console color: Normal
# script layout stuff
BA='=================================================================='
LI='------------------------------------------------------------------'
BAR=${S}$BA${N}
EBAR=${E}$BA${N}
WBAR=${W}$BA${N}
MBAR=${M}$BA${N}
LINE=${S}$LI${N}
ELINE=${E}$LI${N}
MLINE=${M}$LI${N}
WLINE=${W}$LI${N}

########################################################################
####  USER SPECIFIC VARIABLES - REQUIRES rbxi-data/rbxi-values file
####--------------------------------------------------------------------

### See the file rbxi-data/rbxi-values for variable lists and how to
### set them. That file will be the actual data used.
### rbxi cannot run without the user data values file: rbxi-data/rbxi-values

########################################################################
####  STATIC VARIABLES, SHOULD NOT REQUIRE CHANGES
####--------------------------------------------------------------------

### if you do need to change one of these, make sure to change it in the
### user values file: rbxi-data/rbxi-values, not here, or you might lose
### your changes if you update this script.

### Script names/paths
SCRIPT_CONFIGS='/etc/rbxi.conf'
SCRIPT_NAME='rbxi'
SCRIPT_VALUES='rbxi-values'
# http://forums.macosxhints.com/archive/index.php/t-73839.html
SCRIPT_PATH=$( dirname $( lsof -p $$ | grep 'REG' | grep -oE "/.*$(basename $0)$" ) )
SCRIPT_DATA_FILES="$SCRIPT_PATH/rbxi-data/"
SCRIPT_VERSION_NUMBER=$( grep -im 1 'version:' $SCRIPT_PATH/$SCRIPT_NAME | awk '{print $3}' )
SCRIPT_DOWNLOAD='http://rbxi.googlecode.com/svn/trunk/'
SCRIPT_DOWNLOAD_BRANCH_1='http://rbxi.googlecode.com/svn/branches/one/'
SCRIPT_DOWNLOAD_BRANCH_2='http://rbxi.googlecode.com/svn/branches/two/'
SCRIPT_DOWNLOAD_DEV='http://smxi.org/tests/'

#### EXCLUDE LIST FILE NAMES
# NOTE: can be a blank file, but most be located in same directory as rbxi
# if you want them in a different directory, use absolute system paths.
EXCLUDE_ROOT='excludes-root.txt'
EXCLUDE_HOME='excludes-home.txt'
EXCLUDE_DATA_1='excludes-data-1.txt'
EXCLUDE_DATA_2='excludes-data-2.txt'
EXCLUDE_DATA_3='excludes-data-3.txt'
EXCLUDE_DATA_4='excludes-data-4.txt'
EXCLUDE_DATA_5='excludes-data-5.txt'
EXCLUDE_DATA_6='excludes-data-6.txt'
EXCLUDE_DATA_7='excludes-data-7.txt'
EXCLUDE_DATA_8='excludes-data-8.txt'
EXCLUDE_DATA_9='excludes-data-9.txt'
EXCLUDE_DATA_10='excludes-data-10.txt'
EXCLUDE_ROOT_RS='excludes-root-rsync.txt'
EXCLUDE_HOME_RS='excludes-home-rsync.txt'
EXCLUDE_DATA_1_RS='excludes-data-1-rsync.txt'
EXCLUDE_DATA_2_RS='excludes-data-2-rsync.txt'
EXCLUDE_DATA_3_RS='excludes-data-3-rsync.txt'
EXCLUDE_DATA_4_RS='excludes-data-4-rsync.txt'
EXCLUDE_DATA_5_RS='excludes-data-5-rsync.txt'
EXCLUDE_DATA_6_RS='excludes-data-6-rsync.txt'
EXCLUDE_DATA_7_RS='excludes-data-7-rsync.txt'
EXCLUDE_DATA_8_RS='excludes-data-8-rsync.txt'
EXCLUDE_DATA_9_RS='excludes-data-9-rsync.txt'
EXCLUDE_DATA_10_RS='excludes-data-10-rsync.txt'

#### INITIALIZE VARIABLES TO BE SET ELSEWHERE
HOME_BACKUP=''
ROOT_BACKUP=''

# these are optional, only used if DATA_x_DIR is/are set
DATA_1_BACKUP=''
DATA_2_BACKUP=''
DATA_3_BACKUP=''
DATA_4_BACKUP=''
DATA_5_BACKUP=''
DATA_6_BACKUP=''
DATA_7_BACKUP=''
DATA_8_BACKUP=''
DATA_9_BACKUP=''
DATA_10_BACKUP=''

# backup command string holders
HOME_BU_COMMAND=''
ROOT_BU_COMMAND=''
DATA_1_BU_COMMAND=''
DATA_2_BU_COMMAND=''
DATA_3_BU_COMMAND=''
DATA_4_BU_COMMAND=''
DATA_5_BU_COMMAND=''
DATA_6_BU_COMMAND=''
DATA_7_BU_COMMAND=''
DATA_8_BU_COMMAND=''
DATA_9_BU_COMMAND=''
DATA_10_BU_COMMAND=''

# set initial value
ENDING_1='...'
ENDING_2='...'
# for timer function
START_TIME=$( date +%s )

# initialize globals to be set later
BACKUP_CLEAR=''
BACKUP_DURATION=''
# only for logging/history purposes
BACKUP_JOB_NU='default'
DELETE_STATUS='false'
DELETION_TEXT=''
# spinning wheel pid value
GET_PID=''
RSYNC_DELETE=''

## add in user variable values, sticky value file
if [ -f "$SCRIPT_DATA_FILES$SCRIPT_VALUES" ];then
	source $SCRIPT_DATA_FILES$SCRIPT_VALUES
else
	echo "${W}User Values File $SCRIPT_DATA_FILES$SCRIPT_VALUES is missing. Exiting now.${N}"
	exit 1
fi

###################################################################
#####  Functions
###################################################################

#### -------------------------------------------------------------------
#### Options/Parameters
#### -------------------------------------------------------------------

print_usage()
{
	if [ "$1" == 'err' ];then
		echo 'You entered an invalid option. Please use one of the following only:'
	fi
	echo '-A Add backup component. Overrides user set B_SKIP_DATA.. (d|h|hr|1|2|3|4|5|6|7|8|9|10)'
	echo '   d - add all DATA; h - add HOME; r - add ROOT; add DATA 1-10'
	echo '-b Automatic backup, non interactive.'
	echo '-B Change default backup directory (1-10).'
	echo '-c Automatic backup, clean older files, for non-interactive (runs -b also).'
	echo '-C Clone root/home. Skips all data backups. Moves files directly to mounted location."
	echo "   Sets the main mount subdirectory to ''. Takes parameters: (r|h) Clone root/home.'
	echo '-d Automatic backup and delete, non interactive.'
	echo '-D Change default backup sub directory (1-10).'
	echo '-J Start preset backup job (1-10). Cannot be used with any other option.'
	echo "-L Create symbolic link in /usr/local/bin to $SCRIPT_NAME"
	echo '-m Skip the mounting option.'
	echo '-M use alternate mount/umount set (1-10)'
	echo '-o Override default backup application."
	echo "   Requires argument: rs for rsync; rd for rdiff-backup'
	echo '-s Show spinning wheel indicator.'
	echo '-S Skip backup component (d|h|hr|1|2|3|4|5|6|7|8|9|10)'
	echo '   d - skip all DATA; h - skip HOME; r - skip ROOT; skip DATA 1-10'
	echo '-U Update script manually from svn server.'
	echo '-v Show script version and last used information.'
	echo '-h This help menu'
	echo
	echo "In general, avoid using A, D, M, S unless you are creating a backup job -J"
	echo
	echo "-S and -A can be used repeatedly, like so: -S 2 -S 5 -S 9"
	echo "Remember, -A should only be used to override SKIP... that has been set in rbxi-values."
	exit 0
}

### this is not in a function because these variables need to be set on startup
# only use b or d, not both together. If you use both your old backups will be deleted.
# args: $1 - $@ - all args
get_options()
{
	local opt='' setDirectory='' setSubDir='' setMount=''

	while getopts :A:bB:cC:dD:hj:J:LmM:o:sS:Uv!: opt
	do
		case $opt in
			h)	print_usage
				;;
			A)	if [ -n "$( egrep '^(d|h|r|rh|hr|[1-9]|10)$' <<< $OPTARG )" ];then
					set_add_data $OPTARG
				else
					error_handler 13 "-$opt $OPTARG"
				fi
				;;
			b)	B_DO_BACKUP='true'
				;;
			B)	if [ -n "$( egrep '^([1-9]|10)$' <<< $OPTARG )" ];then
					setDirectory="$OPTARG"
				else
					error_handler 13 "-$opt $OPTARG"
				fi
				;;
			c)	B_CLEAN_OLDER='true'
				;;
			C)	if [ -n "$( egrep '^(r|h|rh|hr)$' <<< $OPTARG )" ];then
					B_SKIP_DATA_FULL='true'
					BACKUP_LOCATION=''
					BACKUP_LOCATION_RS=''
					case $OPTARG in
						h)
							B_CLONE_HOME='true'
							HOME_DIR='home'
							;;
						r)
							B_CLONE_ROOT='true'
							ROOT_DIR=''
							;;
						rh|hr)
							B_CLONE_HOME='true'
							B_CLONE_ROOT='true'
							HOME_PATH='home'
							ROOT_PATH=''
							;;
					esac
				else
					error_handler 13 "-$opt $OPTARG"
				fi
				;;
			d)	B_DELETE_BACKUP='true'
				;;
			D)	if [ -n "$( egrep '^([1-9]|10)$' <<< $OPTARG )" ];then
					setSubDir="$OPTARG"
				else
					error_handler 13 "-$opt $OPTARG"
				fi
				;;
			j)	if [ -n "$( egrep '^([1-9]|10)$' <<< $OPTARG )" ];then
					BACKUP_JOB_NU=$OPTARG
				fi
				;;
			J)	if [ -n "$( egrep '^([1-9]|10)$' <<< $OPTARG )" ];then
					set_print_backup_job "$OPTARG" 'set'
				else
					error_handler 13 "-$opt $OPTARG"
				fi
				;;
			L) create_symbolic_link
				exit 0
				;;
			m)	B_SKIP_MOUNT='true'
				;;
			M)	if [ -n "$( egrep '^([1-9]|10)$' <<< $OPTARG )" ];then
					setMount="$OPTARG"
				else
					error_handler 13 "-$opt $OPTARG"
				fi
				;;
			o)	if [ -n "$( egrep '^(rd|rs)$' <<< $OPTARG )" ];then
					case $OPTARG in
						rd)
							BACKUP_APP='rdiff-backup'
							;;
						rs)
							BACKUP_APP='rsync'
							;;
					esac
				else
					error_handler 13 "-$opt $OPTARG"
				fi
				;;
			s)	B_SPINNING_WHEEL='true'
				ENDING_1=': '
				ENDING_2=', watch the spinning wheel: '
				;;
			S)	if [ -n "$( egrep '^(d|h|r|rh|hr|[1-9]|10)$' <<< $OPTARG )" ];then
					set_skip_data $OPTARG
				else
					error_handler 13 "-$opt $OPTARG"
				fi
				;;
			U)	script_self_updater "$SCRIPT_DOWNLOAD" 'svn server'
				;;
			v)	print_version_info
				exit 0
				;;
			!)	# test for various supported methods
				case $OPTARG in
					1)	B_TESTING_1='true'
						;;
					2)	B_TESTING_2='true'
						;;
					3)	B_TESTING_1='true'
						B_TESTING_2='true'
						;;
					10) script_self_updater "$SCRIPT_DOWNLOAD_DEV" 'dev server'
						;;
					11)	script_self_updater "$SCRIPT_DOWNLOAD_BRANCH_1" 'svn: branch one server'
						;;
					12)	script_self_updater "$SCRIPT_DOWNLOAD_BRANCH_2" 'svn: branch two server'
						;;
					http*)
						script_self_updater "$OPTARG" 'alt server'
						;;
					*)	error_handler 11 "-$opt $OPTARG"
						;;
				esac
				;;
			*)	error_handler 7 "-$OPTARG"
				;;
		esac
	done
	# note, because mount will use the first value, I have to set this here, to
	# ensure the proper order. Or you can just set the stuff manually in your rbxi-values file
	if [ -n "$setDirectory" ];then
		set_backup_directory "$setDirectory"
	fi
	if [ -n "$setSubDir" ];then
		set_backup_sub_directory "$setSubDir"
	fi
	if [ -n "$setMount" ];then
		set_mount_data "$setMount"
	fi
}

#### -------------------------------------------------------------------
#### Error Handling
#### -------------------------------------------------------------------

# Error handling
# args: $1 - error number; $2 - optional, extra information
error_handler()
{
	local error_message=''

	# assemble the error message
	case $1 in
		2)	error_message="The component: MOUNT_BU_DISK failed to successfully complete its task. Error code was: $2"
			;;
		3)	error_message="The component: UNMOUNT_BU_DISK failed to successfully complete its task. Error code was: $2"
			;;
		4)	error_message="You must be logged in as root to run this script."
			;;
		5)	error_message="dependency not met: $2 not found in path"
			;;
		6)	error_message="Your backup partition/directory ${C}$BACKUP_DIRECTORY${E} is not present.\nPlease make sure to create it or mount it up before you proceed."
			;;
		7)	error_message="One of the options you entered in your script parameters: $2\nIs not supported. For supported options, check the help menu: $SCRIPT_NAME -h"
			;;
		8)	error_message="the self-updater failed, wget exited with error: $2.\nYou probably need to be root.\nHint, to make for easy updates without being root, do: chown <user name> $SCRIPT_PATH/$SCRIPT_NAME"
			;;
		9)	error_message="missing the required script directory: $2"
			;;
		10)
			error_message="the alt download url you provided: $2\nappears to be wrong, download aborted. Please note, the url\nneeds to end in /, without $SCRIPT_NAME, like: http://yoursite.com/downloads/"
			;;
		11)
			error_message="unsupported testing option argument: -! $2"
			;;
		12)
			error_message="the svn branch download url: $2\nappears to be empty currently. Make sure there is an actual svn branch version\nactive before you try this again. Check http://code.google.com/p/inxi\nto verify the branch status."
			;;
		13)
			error_message="The option argument you gave is not supported: $2"
			;;
		14)
			error_message="You do not have the required backup application installed. Missing: $2"
			;;
		15)
			error_message="You cannot use both -c and -d, only one or the other. Either you are clearing, or deleting."
			;;
		16)
			error_message="B_VARIABLES_SET='false' in the file rbxi-data/$SCRIPT_VALUES must be set to 'true' before you can run $SCRIPT_NAME\nYou must configure that file first, then when you're done, you can the script."
			;;
		17)
			error_message="The backup job you selected ($2) is empty. Please make sure you entered the right number."
			;;
		18)
			error_message="The backup directory you selected ($2) is empty.\nYou cannot backup to, or mount, a blank directory."
			;;
		50)
			error_message="User initiated script exit. Shutting down now."
			;;
		100)
			error_message="$SCRIPT_NAME does not yet support the backup app you requested: $2\nThis support should be coming sometime soon.\nCurrently supported backup applications are: rdiff-backup."
			umount_backup_disk
			;;
		*)	error_message="Unknown error number: $1"
			;;
	esac
	# then print it and exit
	echo -e "${W}Error $1: $error_message${N}"
	exit $1
}

#### -------------------------------------------------------------------
#### Utilities
#### -------------------------------------------------------------------

create_symbolic_link()
{
	local ulbLink="/usr/local/bin/$SCRIPT_NAME"
	local scriptInPath=$( which $SCRIPT_NAME | grep -v "./$SCRIPT_NAME" )

	if [ ! -L $ulbLink -a ! -f $ulbLink -a -z "$scriptInPath" ];then
		check_is_root
		echo "${S}Creating link now...${N}"
		ln -s $SCRIPT_PATH/$SCRIPT_NAME $ulbLink
	else
		echo "${S}$SCRIPT_NAME is already in your system path, or a link to it already exists.${N}"
	fi
}

# args: $1 - main/v
print_history_data()
{
	local lastBackupDirectory='Unset'
	local lastBackupDate='Unset'
	local lastBackupDuration='Unset'
	local lastBackupApp='Unset'
	local lastBackupJobNu='Unset'
	local rdbuHistoryHolder=''
	local rsyncHistoryHolder=''
	local rdbuHistory='Unset'
	local rsyncHistory='Unset'
	local rdbuHistory2=''
	local rsyncHistory2=''

	if [ -f $SCRIPT_CONFIGS ];then
		lastBackupDirectory=$( grep 'last-backup-directory=' $SCRIPT_CONFIGS | cut -d '=' -f 2 )
		lastBackupDate=$( grep 'last-backup-date=' $SCRIPT_CONFIGS | cut -d '=' -f 2 )
		lastBackupDuration=$( grep 'last-backup-duration=' $SCRIPT_CONFIGS | cut -d '=' -f 2 )
		lastBackupApp=$( grep 'last-backup-app=' $SCRIPT_CONFIGS | cut -d '=' -f 2 )
		lastBackupJobNu=$( grep 'last-backup-job=' $SCRIPT_CONFIGS | cut -d '=' -f 2 )
		# add line breaks because output is too long for single line
		rdbuHistoryHolder="$( grep 'rdbu-backup-history=' $SCRIPT_CONFIGS | cut -d '=' -f 2 )"
		rsyncHistoryHolder="$( grep 'rsync-backup-history=' $SCRIPT_CONFIGS | cut -d '=' -f 2 )"
		rdbuHistory="$( cut -d '~' -f 1 <<< $rdbuHistoryHolder )"
		rsyncHistory="$( cut -d '~' -f 1 <<< $rsyncHistoryHolder )"

		if [ -n "$( grep '~' <<< $rdbuHistoryHolder )" ];then
			rdbuHistory2="$( cut -d '~' -f 2 <<< $rdbuHistoryHolder )"
			rdbuHistory2='echo "                     ${S}'$rdbuHistory2'${N}"'
		fi
		if [ -n "$( grep '~' <<< $rsyncHistoryHolder )" ];then
			rsyncHistory2="$( cut -d '~' -f 2 <<< $rsyncHistoryHolder )"
			rsyncHistory2='echo "                      ${S}'$rsyncHistory2'${N}"'
		fi
	fi
	echo "${S}Last Backup Date: $lastBackupDate${N}"
	echo "${S}Last Backup Directory: $lastBackupDirectory${N}"
	echo "${S}Last Backup Program: $lastBackupApp${N}"
	echo "${S}Last Backup Job Number (or default): $lastBackupJobNu${N}"
	if [ "$1" == 'main' ];then
		case "$BACKUP_APP" in
			rdiff-backup)
				echo "${S}Rdiff-backup history: $rdbuHistory${N}"
				eval "$rdbuHistory2"
				;;
			rsync)
				echo "${S}Rsync backup history: $rsyncHistory${N}"
				eval "$rsyncHistory2"
				;;
		esac
	else
		echo "${S}Rdiff-backup history: $rdbuHistory${N}"
		eval "$rdbuHistory2"
		echo "${S}Rsync backup history: $rsyncHistory${N}"
		eval "$rsyncHistory2"
	fi
}

## print out version information for -v
print_version_info()
{
	local last_modified=$( grep -im 1 'date:' $SCRIPT_PATH/$SCRIPT_NAME | awk '{print $3,$4,$5}' )

	echo "$SCRIPT_NAME - the universal, portable, system backup script."
	echo "Version: $SCRIPT_VERSION_NUMBER"
	echo "Script Last Modified: $last_modified"
	echo "Script Location: $SCRIPT_PATH${N}"
	print_history_data
}

# args: $1 - download url, not including file name; $2 - string to print out
# note that $1 must end in / to properly construct the url path
script_self_updater()
{
	local wget_error=0

	echo "Starting $SCRIPT_NAME self updater."
	echo "Currently running $SCRIPT_NAME version number: $SCRIPT_VERSION_NUMBER"
	echo "Updating $SCRIPT_NAME in $SCRIPT_PATH using $2 as download source..."
	# first test if path is good, need to make sure it's good because we're -O overwriting file
	wget -q --spider $1$SCRIPT_NAME || wget_error=$?
	# then do the actual download
	if [[ $wget_error -eq 0 ]];then
		wget -q -O $SCRIPT_PATH/$SCRIPT_NAME $1$SCRIPT_NAME || wget_error=$?
		if [[ $wget_error -eq 0 ]];then
			SCRIPT_VERSION_NUMBER=$( grep -im 1 'version:' $SCRIPT_PATH/$SCRIPT_NAME | awk '{print $3}' )
			echo "Successfully updated to $2 version: $SCRIPT_VERSION_NUMBER"
			echo "To run the new version, just start $SCRIPT_NAME again."
			exit 0
		fi
	fi
	# now run the error handlers on any wget failure
	if [[ $wget_error -gt 0 ]];then
		if [[ $2 == 'svn server' ]];then
			error_handler 8 "$wget_error"
		elif [[ $2 == 'alt server' ]];then
			error_handler 10 "$1"
		else
			error_handler 12 "$1"
		fi
	fi
}

# creates the spinning wheel if script starts with -s option, and shows completion
spinning_wheel_activity_indicator()
{
	local completionText=''

	if [ "$1" == 'delete' ];then
		completionText='backup directories removed'
	fi
	if [ "$1" == 'backup' ];then
		completionText="$2 backed up"
	fi

	echo -n ${S}
	# while kill -0 $GET_PID
	while [ -e /proc/$GET_PID ]
	do
		sleep $SLEEP_TIME_SPINNER
		echo -n '|'
		echo -ne "\b"
		sleep $SLEEP_TIME_SPINNER
		echo -n '/'
		echo -ne "\b"
		sleep $SLEEP_TIME_SPINNER
		echo -n '-'
		echo -ne "\b"
		sleep $SLEEP_TIME_SPINNER
		echo -n "\\"
		echo -ne "\b"
	done
	echo -ne "\b $completionText"
	echo ${N}
}

# args: $1 umount/
trap_handler()
{
 	case "$1" in
 		umount)
 			echo "${S}Waiting a few seconds to let disk writes sync before exiting...${N}"
 			sleep 5 # give the disk time sync its writes before umount...
 			umount_backup_disk
 			# set trap to null to avoid loops for final exits
			trap - INT TERM EXIT
 			error_handler 50
 			;;
 	esac
}

#### -------------------------------------------------------------------
#### basic tests
#### -------------------------------------------------------------------

check_is_root()
{
	if [ "$( whoami )" != "root" ];then
		error_handler 4
	fi
}

check_startup_stuff()
{
	check_is_root
	create_etc_configs
	if [ ! -d $BACKUP_DIRECTORY ];then
		error_handler 9 $BACKUP_DIRECTORY
	fi
	check_bu_app_installed
	if [ "$B_CLEAN_OLDER" == 'true' -a "$B_DELETE_BACKUP" == 'true' ];then
		error_handler 15
	fi
	if [ "$B_VARIABLES_SET" != 'true' ];then
		error_handler 16
	fi
}

check_script_path()
{
	local ExDir=$( dirname $0 )

	if [ "$( pwd )" != "$ExDir" -a "$ExDir" != '.' ];then
		cd $ExDir
	fi
}

check_bu_app_installed()
{
	local pathExists='' appToCheck=''
	# this must set error to /dev/null to avoid false positive in some cases
	local appWhich="$( which $BACKUP_APP )"

	# more handling is required for cron jobs, which might not show which output
	case $BACKUP_APP in
		rdiff-backup)
			appToCheck=$RDIFF_PATH
			;;
		rsync)
			appToCheck=$RSYNC_PATH
			;;
	esac
	# checking the actual paths here, not relying on unreliable which output
	if [ ! -x "$appWhich" -a ! -x $appToCheck ];then
		error_handler 14 $BACKUP_APP
	fi
}

create_etc_configs()
{
	if [ ! -f $SCRIPT_CONFIGS ];then
		touch $SCRIPT_CONFIGS
		echo 'last-backup-directory=Unset' >> $SCRIPT_CONFIGS
		echo 'last-backup-date=Unset' >> $SCRIPT_CONFIGS
		echo 'last-backup-duration=Unset' >> $SCRIPT_CONFIGS
	fi
	if [ -z "$( grep 'rdbu-backup-history=' $SCRIPT_CONFIGS )" ];then
		echo 'rdbu-backup-history=Unset' >> $SCRIPT_CONFIGS
	fi
	if [ -z "$( grep 'rsync-backup-history=' $SCRIPT_CONFIGS )" ];then
		echo 'rsync-backup-history=Unset' >> $SCRIPT_CONFIGS
	fi
	if [ -z "$( grep 'last-backup-app=' $SCRIPT_CONFIGS )" ];then
		echo 'last-backup-app=Unset' >> $SCRIPT_CONFIGS
	fi
	if [ -z "$( grep 'last-backup-job=' $SCRIPT_CONFIGS )" ];then
		echo 'last-backup-job=Unset' >> $SCRIPT_CONFIGS
	fi
}

#### -------------------------------------------------------------------
#### set data functions
#### -------------------------------------------------------------------

# load proper values for locations and command strings
set_primary_backup_data()
{
	case "$BACKUP_APP" in
		rsync)
			# update global file names.
			# First make sure no user error with the directory name occured with options
			if [ -z "$BACKUP_DIRECTORY_RS" ];then
				error_handler 18 'BACKUP_DIRECTORY_RS'
			fi
			# note: these values were set in set_backup_directory
			# and set_backup_sub_directory if -B or -D were used
			BACKUP_LOCATION=$BACKUP_DIRECTORY_RS$BACKUP_SUB_DIR_RS
			EXCLUDE_ROOT=$EXCLUDE_ROOT_RS
			EXCLUDE_HOME=$EXCLUDE_HOME_RS
			EXCLUDE_DATA_1=$EXCLUDE_DATA_1_RS
			EXCLUDE_DATA_2=$EXCLUDE_DATA_2_RS
			EXCLUDE_DATA_3=$EXCLUDE_DATA_3_RS
			EXCLUDE_DATA_4=$EXCLUDE_DATA_4_RS
			EXCLUDE_DATA_5=$EXCLUDE_DATA_5_RS
			EXCLUDE_DATA_6=$EXCLUDE_DATA_6_RS
			EXCLUDE_DATA_7=$EXCLUDE_DATA_7_RS
			EXCLUDE_DATA_8=$EXCLUDE_DATA_8_RS
			EXCLUDE_DATA_9=$EXCLUDE_DATA_9_RS
			EXCLUDE_DATA_10=$EXCLUDE_DATA_10_RS
			;;
		rdiff-backup)
			# First make sure no user error with the directory name occured with options
			if [ -z "$BACKUP_DIRECTORY" ];then
				error_handler 18 'BACKUP_DIRECTORY'
			fi
			BACKUP_LOCATION=$BACKUP_DIRECTORY$BACKUP_SUB_DIR
			;;
	esac
	if [ -z "$BACKUP_LOCATION" ];then
		error_handler 19
	fi
}

# create backup directory then set backup directory names
set_backup_directory_data()
{
	local month=$( date +%m )

	echo $LINE
	echo "${S}Working backup location: ${C}$BACKUP_LOCATION${N}"

	# make sure it exists
	if [ ! -d "$BACKUP_LOCATION" -a -n "$BACKUP_LOCATION" ];then
		mkdir $BACKUP_LOCATION
	fi

	# assemble the backup paths, first two can be null if it's a clone
	if [ "$HOME_DIR" != '' -o "$B_CLONE_HOME" == 'true' ];then
		HOME_BACKUP=$BACKUP_LOCATION/$HOME_DIR
	fi
	if [ "$ROOT_DIR" != '' -o "$B_CLONE_ROOT" == 'true' ];then
		ROOT_BACKUP=$BACKUP_LOCATION/$ROOT_DIR
	fi
	if [ "$DATA_1_DIR" != '' ];then
		DATA_1_BACKUP=$BACKUP_LOCATION/$DATA_1_DIR
	fi
	if [ "$DATA_2_DIR" != '' ];then
		DATA_2_BACKUP=$BACKUP_LOCATION/$DATA_2_DIR
	fi
	if [ "$DATA_3_DIR" != '' ];then
		DATA_3_BACKUP=$BACKUP_LOCATION/$DATA_3_DIR
	fi
	if [ "$DATA_4_DIR" != '' ];then
		DATA_4_BACKUP=$BACKUP_LOCATION/$DATA_4_DIR
	fi
	if [ "$DATA_5_DIR" != '' ];then
		DATA_5_BACKUP=$BACKUP_LOCATION/$DATA_5_DIR
	fi
	if [ "$DATA_6_DIR" != '' ];then
		DATA_6_BACKUP=$BACKUP_LOCATION/$DATA_6_DIR
	fi
	if [ "$DATA_7_DIR" != '' ];then
		DATA_7_BACKUP=$BACKUP_LOCATION/$DATA_7_DIR
	fi
	if [ "$DATA_8_DIR" != '' ];then
		DATA_8_BACKUP=$BACKUP_LOCATION/$DATA_8_DIR
	fi
	if [ "$DATA_9_DIR" != '' ];then
		DATA_9_BACKUP=$BACKUP_LOCATION/$DATA_9_DIR
	fi
	if [ "$DATA_10_DIR" != '' ];then
		DATA_10_BACKUP=$BACKUP_LOCATION/$DATA_10_DIR
	fi
}

set_backup_commands()
{
	case "$BACKUP_APP" in
		rsync)
			if [ "$B_CLEAN_OLDER" != 'true' ];then
				RSYNC_DELETE=' --delete --delete-excluded '
			fi
			# set commands
			HOME_BU_COMMAND="$RSYNC_PATH -a --exclude-from=$SCRIPT_DATA_FILES$EXCLUDE_HOME $RSYNC_DELETE $RSYNC_EXTRA_OPTIONS $HOME_PATH $HOME_BACKUP"
			ROOT_BU_COMMAND="$RSYNC_PATH -a --exclude-from=$SCRIPT_DATA_FILES$EXCLUDE_ROOT $RSYNC_DELETE $RSYNC_EXTRA_OPTIONS $ROOT_PATH $ROOT_BACKUP"
			DATA_1_BU_COMMAND="$RSYNC_PATH -a --exclude-from=$SCRIPT_DATA_FILES$EXCLUDE_DATA_1 $RSYNC_DELETE $RSYNC_EXTRA_OPTIONS $DATA_1_PATH $DATA_1_BACKUP"
			DATA_2_BU_COMMAND="$RSYNC_PATH -a --exclude-from=$SCRIPT_DATA_FILES$EXCLUDE_DATA_2 $RSYNC_DELETE $RSYNC_EXTRA_OPTIONS $DATA_2_PATH $DATA_2_BACKUP"
			DATA_3_BU_COMMAND="$RSYNC_PATH -a --exclude-from=$SCRIPT_DATA_FILES$EXCLUDE_DATA_3 $RSYNC_DELETE $RSYNC_EXTRA_OPTIONS $DATA_3_PATH $DATA_3_BACKUP"
			DATA_4_BU_COMMAND="$RSYNC_PATH -a --exclude-from=$SCRIPT_DATA_FILES$EXCLUDE_DATA_4 $RSYNC_DELETE $RSYNC_EXTRA_OPTIONS $DATA_4_PATH $DATA_4_BACKUP"
			DATA_5_BU_COMMAND="$RSYNC_PATH -a --exclude-from=$SCRIPT_DATA_FILES$EXCLUDE_DATA_5 $RSYNC_DELETE $RSYNC_EXTRA_OPTIONS $DATA_5_PATH $DATA_5_BACKUP"
			DATA_6_BU_COMMAND="$RSYNC_PATH -a --exclude-from=$SCRIPT_DATA_FILES$EXCLUDE_DATA_6 $RSYNC_DELETE $RSYNC_EXTRA_OPTIONS $DATA_6_PATH $DATA_6_BACKUP"
			DATA_7_BU_COMMAND="$RSYNC_PATH -a --exclude-from=$SCRIPT_DATA_FILES$EXCLUDE_DATA_7 $RSYNC_DELETE $RSYNC_EXTRA_OPTIONS $DATA_7_PATH $DATA_7_BACKUP"
			DATA_8_BU_COMMAND="$RSYNC_PATH -a --exclude-from=$SCRIPT_DATA_FILES$EXCLUDE_DATA_8 $RSYNC_DELETE $RSYNC_EXTRA_OPTIONS $DATA_8_PATH $DATA_8_BACKUP"
			DATA_9_BU_COMMAND="$RSYNC_PATH -a --exclude-from=$SCRIPT_DATA_FILES$EXCLUDE_DATA_9 $RSYNC_DELETE $RSYNC_EXTRA_OPTIONS $DATA_9_PATH $DATA_9_BACKUP"
			DATA_10_BU_COMMAND="$RSYNC_PATH -a --exclude-from=$SCRIPT_DATA_FILES$EXCLUDE_DATA_10 $RSYNC_DELETE $RSYNC_EXTRA_OPTIONS $DATA_10_PATH $DATA_10_BACKUP"

			# set text
			BACKUP_CLEAR='Backing up'
			# rest to false so main backup function can finish up
			B_CLEAN_OLDER='false'
			;;
		rdiff-backup)
			# set commands
			# http://www.mail-archive.com/rdiff-backup-users@nongnu.org/msg01212.html
			# --exclude-sockets to get rid of that dumb socket error
			if [ "$B_CLEAN_OLDER" != 'true' ];then
				# set commands
				HOME_BU_COMMAND="$RDIFF_PATH --exclude-sockets --exclude-globbing-filelist $SCRIPT_DATA_FILES$EXCLUDE_HOME $RDIFF_EXTRA_OPTIONS $HOME_PATH $HOME_BACKUP"
				ROOT_BU_COMMAND="$RDIFF_PATH --exclude-sockets --exclude-globbing-filelist $SCRIPT_DATA_FILES$EXCLUDE_ROOT $RDIFF_EXTRA_OPTIONS $ROOT_PATH $ROOT_BACKUP"
				DATA_1_BU_COMMAND="$RDIFF_PATH --exclude-sockets --exclude-globbing-filelist $SCRIPT_DATA_FILES$EXCLUDE_DATA_1 $RDIFF_EXTRA_OPTIONS $DATA_1_PATH $DATA_1_BACKUP"
				DATA_2_BU_COMMAND="$RDIFF_PATH --exclude-sockets --exclude-globbing-filelist $SCRIPT_DATA_FILES$EXCLUDE_DATA_2 $RDIFF_EXTRA_OPTIONS $DATA_2_PATH $DATA_2_BACKUP"
				DATA_3_BU_COMMAND="$RDIFF_PATH --exclude-sockets --exclude-globbing-filelist $SCRIPT_DATA_FILES$EXCLUDE_DATA_3 $RDIFF_EXTRA_OPTIONS $DATA_3_PATH $DATA_3_BACKUP"
				DATA_4_BU_COMMAND="$RDIFF_PATH --exclude-sockets --exclude-globbing-filelist $SCRIPT_DATA_FILES$EXCLUDE_DATA_4 $RDIFF_EXTRA_OPTIONS $DATA_4_PATH $DATA_4_BACKUP"
				DATA_5_BU_COMMAND="$RDIFF_PATH --exclude-sockets --exclude-globbing-filelist $SCRIPT_DATA_FILES$EXCLUDE_DATA_5 $RDIFF_EXTRA_OPTIONS $DATA_5_PATH $DATA_5_BACKUP"
				DATA_6_BU_COMMAND="$RDIFF_PATH --exclude-sockets --exclude-globbing-filelist $SCRIPT_DATA_FILES$EXCLUDE_DATA_6 $RDIFF_EXTRA_OPTIONS $DATA_6_PATH $DATA_6_BACKUP"
				DATA_7_BU_COMMAND="$RDIFF_PATH --exclude-sockets --exclude-globbing-filelist $SCRIPT_DATA_FILES$EXCLUDE_DATA_7 $RDIFF_EXTRA_OPTIONS $DATA_7_PATH $DATA_7_BACKUP"
				DATA_8_BU_COMMAND="$RDIFF_PATH --exclude-sockets --exclude-globbing-filelist $SCRIPT_DATA_FILES$EXCLUDE_DATA_8 $RDIFF_EXTRA_OPTIONS $DATA_8_PATH $DATA_8_BACKUP"
				DATA_9_BU_COMMAND="$RDIFF_PATH --exclude-sockets --exclude-globbing-filelist $SCRIPT_DATA_FILES$EXCLUDE_DATA_9 $RDIFF_EXTRA_OPTIONS $DATA_9_PATH $DATA_9_BACKUP"
				DATA_10_BU_COMMAND="$RDIFF_PATH --exclude-sockets --exclude-globbing-filelist $SCRIPT_DATA_FILES$EXCLUDE_DATA_10 $RDIFF_EXTRA_OPTIONS $DATA_10_PATH $DATA_10_BACKUP"

				# set text
				BACKUP_CLEAR='Backing up'
			else
				# set commands
				HOME_BU_COMMAND="$RDIFF_PATH --force --remove-older-than $RDIFF_REMOVE_TIME $HOME_BACKUP"
				ROOT_BU_COMMAND="$RDIFF_PATH --force --remove-older-than $RDIFF_REMOVE_TIME $ROOT_BACKUP"
				DATA_1_BU_COMMAND="$RDIFF_PATH --force --remove-older-than $RDIFF_REMOVE_TIME $DATA_1_BACKUP"
				DATA_2_BU_COMMAND="$RDIFF_PATH --force --remove-older-than $RDIFF_REMOVE_TIME $DATA_2_BACKUP"
				DATA_3_BU_COMMAND="$RDIFF_PATH --force --remove-older-than $RDIFF_REMOVE_TIME $DATA_3_BACKUP"
				DATA_4_BU_COMMAND="$RDIFF_PATH --force --remove-older-than $RDIFF_REMOVE_TIME $DATA_4_BACKUP"
				DATA_5_BU_COMMAND="$RDIFF_PATH --force --remove-older-than $RDIFF_REMOVE_TIME $DATA_5_BACKUP"
				DATA_6_BU_COMMAND="$RDIFF_PATH --force --remove-older-than $RDIFF_REMOVE_TIME $DATA_6_BACKUP"
				DATA_7_BU_COMMAND="$RDIFF_PATH --force --remove-older-than $RDIFF_REMOVE_TIME $DATA_7_BACKUP"
				DATA_8_BU_COMMAND="$RDIFF_PATH --force --remove-older-than $RDIFF_REMOVE_TIME $DATA_8_BACKUP"
				DATA_9_BU_COMMAND="$RDIFF_PATH --force --remove-older-than $RDIFF_REMOVE_TIME $DATA_9_BACKUP"
				DATA_10_BU_COMMAND="$RDIFF_PATH --force --remove-older-than $RDIFF_REMOVE_TIME $DATA_10_BACKUP"

				# set text
				BACKUP_CLEAR="Removing all increments older than $RDIFF_REMOVE_TIME from"
			fi
			;;
	esac
}

# all error null directory handling is done in the final set_primary_backup_data function
# args: $1 - backup directory number
set_backup_directory()
{
	case $1 in
		1)
			BACKUP_DIRECTORY=$BACKUP_DIRECTORY_1
			BACKUP_DIRECTORY_RS=$BACKUP_DIRECTORY_1_RS
			;;
		2)
			BACKUP_DIRECTORY=$BACKUP_DIRECTORY_2
			BACKUP_DIRECTORY_RS=$BACKUP_DIRECTORY_2_RS
			;;
		3)
			BACKUP_DIRECTORY=$BACKUP_DIRECTORY_3
			BACKUP_DIRECTORY_RS=$BACKUP_DIRECTORY_3_RS
			;;
		4)
			BACKUP_DIRECTORY=$BACKUP_DIRECTORY_4
			BACKUP_DIRECTORY_RS=$BACKUP_DIRECTORY_4_RS
			;;
		5)
			BACKUP_DIRECTORY=$BACKUP_DIRECTORY_5
			BACKUP_DIRECTORY_RS=$BACKUP_DIRECTORY_5_RS
			;;
		6)
			BACKUP_DIRECTORY=$BACKUP_DIRECTORY_6
			BACKUP_DIRECTORY_RS=$BACKUP_DIRECTORY_6_RS
			;;
		7)
			BACKUP_DIRECTORY=$BACKUP_DIRECTORY_7
			BACKUP_DIRECTORY_RS=$BACKUP_DIRECTORY_7_RS
			;;
		8)
			BACKUP_DIRECTORY=$BACKUP_DIRECTORY_8
			BACKUP_DIRECTORY_RS=$BACKUP_DIRECTORY_8_RS
			;;
		9)
			BACKUP_DIRECTORY=$BACKUP_DIRECTORY_9
			BACKUP_DIRECTORY_RS=$BACKUP_DIRECTORY_9_RS
			;;
		10)
			BACKUP_DIRECTORY=$BACKUP_DIRECTORY_10
			BACKUP_DIRECTORY_RS=$BACKUP_DIRECTORY_10_RS
			;;
	esac
}

# args: $1 - backup directory number
set_backup_sub_directory()
{
	case $1 in
		1)
			BACKUP_SUB_DIR=$BACKUP_SUB_DIR_1
			BACKUP_SUB_DIR_RS=$BACKUP_SUB_DIR_1_RS
			;;
		2)
			BACKUP_SUB_DIR=$BACKUP_SUB_DIR_2
			BACKUP_SUB_DIR_RS=$BACKUP_SUB_DIR_2_RS
			;;
		3)
			BACKUP_SUB_DIR=$BACKUP_SUB_DIR_3
			BACKUP_SUB_DIR_RS=$BACKUP_SUB_DIR_3_RS
			;;
		4)
			BACKUP_SUB_DIR=$BACKUP_SUB_DIR_4
			BACKUP_SUB_DIR_RS=$BACKUP_SUB_DIR_4_RS
			;;
		5)
			BACKUP_SUB_DIR=$BACKUP_SUB_DIR_5
			BACKUP_SUB_DIR_RS=$BACKUP_SUB_DIR_5_RS
			;;
		6)
			BACKUP_SUB_DIR=$BACKUP_SUB_DIR_6
			BACKUP_SUB_DIR_RS=$BACKUP_SUB_DIR_6_RS
			;;
		7)
			BACKUP_SUB_DIR=$BACKUP_SUB_DIR_7
			BACKUP_SUB_DIR_RS=$BACKUP_SUB_DIR_7_RS
			;;
		8)
			BACKUP_SUB_DIR=$BACKUP_SUB_DIR_8
			BACKUP_SUB_DIR_RS=$BACKUP_SUB_DIR_8_RS
			;;
		9)
			BACKUP_SUB_DIR=$BACKUP_SUB_DIR_9
			BACKUP_SUB_DIR_RS=$BACKUP_SUB_DIR_9_RS
			;;
		10)
			BACKUP_SUB_DIR=$BACKUP_SUB_DIR_10
			BACKUP_SUB_DIR_RS=$BACKUP_SUB_DIR_10_RS
			;;
	esac
}

# args: $1 - mount number
set_mount_data()
{
	case $1 in
		1)
			MOUNT_BU_DISK=$MOUNT_BU_DISK_1
			UNMOUNT_BU_DISK=$UNMOUNT_BU_DISK_1
			;;
		2)
			MOUNT_BU_DISK=$MOUNT_BU_DISK_2
			UNMOUNT_BU_DISK=$UNMOUNT_BU_DISK_2
			;;
		3)
			MOUNT_BU_DISK=$MOUNT_BU_DISK_3
			UNMOUNT_BU_DISK=$UNMOUNT_BU_DISK_3
			;;
		4)
			MOUNT_BU_DISK=$MOUNT_BU_DISK_4
			UNMOUNT_BU_DISK=$UNMOUNT_BU_DISK_4
			;;
		5)
			MOUNT_BU_DISK=$MOUNT_BU_DISK_5
			UNMOUNT_BU_DISK=$UNMOUNT_BU_DISK_5
			;;
		6)
			MOUNT_BU_DISK=$MOUNT_BU_DISK_6
			UNMOUNT_BU_DISK=$UNMOUNT_BU_DISK_6
			;;
		7)
			MOUNT_BU_DISK=$MOUNT_BU_DISK_7
			UNMOUNT_BU_DISK=$UNMOUNT_BU_DISK_7
			;;
		8)
			MOUNT_BU_DISK=$MOUNT_BU_DISK_8
			UNMOUNT_BU_DISK=$UNMOUNT_BU_DISK_8
			;;
		9)
			MOUNT_BU_DISK=$MOUNT_BU_DISK_9
			UNMOUNT_BU_DISK=$UNMOUNT_BU_DISK_9
			;;
		10)
			MOUNT_BU_DISK=$MOUNT_BU_DISK_10
			UNMOUNT_BU_DISK=$UNMOUNT_BU_DISK_10
			;;
	esac
}

# args: $1 - item to add, this can be called repeatedly
set_add_data()
{
	case $1 in
		d)
			B_SKIP_DATA_FULL='false'
			B_SKIP_DATA_1='false'
			B_SKIP_DATA_2='false'
			B_SKIP_DATA_3='false'
			B_SKIP_DATA_4='false'
			B_SKIP_DATA_5='false'
			B_SKIP_DATA_6='false'
			B_SKIP_DATA_7='false'
			B_SKIP_DATA_8='false'
			B_SKIP_DATA_9='false'
			B_SKIP_DATA_10='false'
			;;
		h)
			B_SKIP_HOME='false'
			;;
		r)
			B_SKIP_ROOT='false'
			;;
		rh|hr)
			B_SKIP_HOME='false'
			B_SKIP_ROOT='false'
			;;
		# note that B_SKIP_DATA_FULL='false' is required
		# to override the block off switch for DATA
		1)
			B_SKIP_DATA_1='false'
			B_SKIP_DATA_FULL='false'
			;;
		2)
			B_SKIP_DATA_2='false'
			B_SKIP_DATA_FULL='false'
			;;
		3)
			B_SKIP_DATA_3='false'
			B_SKIP_DATA_FULL='false'
			;;
		4)
			B_SKIP_DATA_4='false'
			B_SKIP_DATA_FULL='false'
			;;
		5)
			B_SKIP_DATA_5='false'
			B_SKIP_DATA_FULL='false'
			;;
		6)
			B_SKIP_DATA_6='false'
			B_SKIP_DATA_FULL='false'
			;;
		7)
			B_SKIP_DATA_7='false'
			B_SKIP_DATA_FULL='false'
			;;
		8)
			B_SKIP_DATA_8='false'
			B_SKIP_DATA_FULL='false'
			;;
		9)
			B_SKIP_DATA_9='false'
			B_SKIP_DATA_FULL='false'
			;;
		10)
			B_SKIP_DATA_10='false'
			B_SKIP_DATA_FULL='false'
			;;
	esac
}

# args: $1 - item to skip, this can be called repeatedly
set_skip_data()
{
	case $1 in
		d)
			B_SKIP_DATA_FULL='true'
			;;
		h)
			B_SKIP_HOME='true'
			;;
		r)
			B_SKIP_ROOT='true'
			;;
		rh|hr)
			B_SKIP_HOME='true'
			B_SKIP_ROOT='true'
			;;
		1)
			B_SKIP_DATA_1='true'
			;;
		2)
			B_SKIP_DATA_2='true'
			;;
		3)
			B_SKIP_DATA_3='true'
			;;
		4)
			B_SKIP_DATA_4='true'
			;;
		5)
			B_SKIP_DATA_5='true'
			;;
		6)
			B_SKIP_DATA_6='true'
			;;
		7)
			B_SKIP_DATA_7='true'
			;;
		8)
			B_SKIP_DATA_8='true'
			;;
		9)
			B_SKIP_DATA_9='true'
			;;
		10)
			B_SKIP_DATA_10='true'
			;;
	esac
}

# args: $1 - backup job number; $2 - set/print
set_print_backup_job()
{
	local backupJob=''

	case $1 in
		1)
			backupJob="$BACKUP_JOB_1"
			;;
		2)
			backupJob="$BACKUP_JOB_2"
			;;
		3)
			backupJob="$BACKUP_JOB_3"
			;;
		4)
			backupJob="$BACKUP_JOB_4"
			;;
		5)
			backupJob="$BACKUP_JOB_5"
			;;
		6)
			backupJob="$BACKUP_JOB_6"
			;;
		7)
			backupJob="$BACKUP_JOB_7"
			;;
		8)
			backupJob="$BACKUP_JOB_8"
			;;
		9)
			backupJob="$BACKUP_JOB_9"
			;;
		10)
			backupJob="$BACKUP_JOB_10"
			;;
	esac
	# make sure the job has content
	if [ -n "$backupJob" ];then
		if [ "$2" == 'set' ];then
			echo "${S}Your job presets are: ${C}$backupJob"
			echo "${S}Restarting $SCRIPT_NAME to run backup job ${C}$1${S} now...${N}"
			sleep 1
			$SCRIPT_PATH/$SCRIPT_NAME -j $1 $backupJob
			exit 0
		elif [ "$2" == 'print' ];then
			echo "${S}Your job presets are: ${C}$backupJob${N}"
		fi
	else
		error_handler 17 "$1"
	fi
}

#### -------------------------------------------------------------------
#### primary backup tools
#### -------------------------------------------------------------------

run_backup_question()
{
	local opt='' options='' doTheBackup='' removeBackup='' repeat=''
	local removeDeleteOpt=''

	echo $MLINE
	print_history_data 'main'
	echo $MLINE
	if [ "$BACKUP_JOB_NU" != 'default' ];then
		echo "${S}You are currently about to run backup job number: ${C}$BACKUP_JOB_NU"
		set_print_backup_job "$BACKUP_JOB_NU" 'print'
		echo $LINE
	fi
	case "$BACKUP_APP" in
		rdiff-backup)
			echo "${S}Backups use standard $BACKUP_APP settings, which lets you restore from any time"
			echo "period stored in the full backup. After first full backup, the next ones will be"
			echo "incremental backups, which run much faster since they only backup changed files."
			;;
		rsync)
			echo "${S}This will backup your system to the backup directories you have already set up"
			echo "for your $BACKUP_APP backup."
			;;
	esac
	echo $LINE
	echo "${S}Please select one of the following numbers to assign the correct backup option."
	echo "1 - backs up as usual with $BACKUP_APP. Does not remove old backups."
	case "$BACKUP_APP" in
		rdiff-backup)
			echo "2 - clean-older - Removes all backup increments older than your time setting: $RDIFF_REMOVE_TIME"
			echo "    After the cleanup, runs a new standard backup."
			removeDeleteOpt='clean-older'
			;;
		rsync)
			echo "2 - clean-obsolete - Removes all backed up up files that have been deleted from"
			echo "    your current install."
			removeDeleteOpt='clean-obsolete'
			;;
	esac
	echo "3 - backs up but first deletes old backups. This is final, so once you agree to"
	echo "    remove, no restore of older material will be possible. This will delete the"
	echo "    backup that corresponds to the currently active primary backup directory."
	echo
	echo "4 - Quit, don't do the backup after all."
	echo $LINE
	options="backup-normal $removeDeleteOpt backup-and-delete-old quit"
	select opt in $options
	do
		case $opt in
			backup-normal)
				doTheBackup='true'
				;;
			backup-and-delete-old)
				removeBackup='true'
				doTheBackup='true'
				;;
			clean-older)
				# first get rid of all older files and increments
				B_CLEAN_OLDER='true'
				run_backup_components
				B_CLEAN_OLDER='false'
				doTheBackup='true'
				;;
			clean-obsolete)
				B_CLEAN_OLDER='true'
				doTheBackup='true'
				;;
			quit)
				echo "${S}Ok, no backup today, exiting the script...${N}"
				exit 0
				;;
			*)
				echo $ELINE
				echo "${E}You need to type in one of above the numbers!!${N}"
				repeat='true'
				;;
		esac
		break
	done

	if [ "$repeat" == 'true' ];then
		run_backup_question
	fi
	if [ "$removeBackup" == 'true' ];then
		remove_backups
	fi
	if [ "$doTheBackup" == 'true' ];then
		run_backup_components
	fi
}

remove_backups()
{
	local options='' opt='' repeat='' deleteBackup='' directory='' directories=''
	local backupDirectories=$( ls $BACKUP_LOCATION )

	# dump line breaks
	for directory in $backupDirectories
	do
		directories="$directories$directory "
	done
	if [ -z "$backupDirectories" ];then
		directories='No Directories to Delete '
	fi

	echo $LINE
	echo "${Q}Are you sure you want to delete the contents of your backup directories?${N}"
	echo
	echo "${S}These directories will be removed: ${C}$directories${S}in ${C}$BACKUP_LOCATION"
	echo
	echo "${C}1 - yes-delete${S} - Deletes ALL directories in ${C}$BACKUP_LOCATION"
	echo "${C}2 - no-keep${S} - Keeps current data in ${C}$BACKUP_LOCATION${S} and backs up as normal."
	echo "${C}3 - quit${S} - Quit, think about it later."
	echo $LINE
	options='yes-delete no-keep quit'
	select opt in $options
	do
		case $opt in
			yes-delete)
				deleteBackup='true'
				;;
			no-keep)
				echo $LINE
				echo "${S}Ok, no deleting of them today."
				echo
				echo "Continuing with backup now...${N}"
				;;
			quit)
				echo "${S}Ok, no backup today, exiting the script...${N}"
				exit 0
				;;
			*)
				echo $ELINE
				echo "${E}You need to type in one of above the numbers!!${N}"
				repeat='true'
				;;
		esac
		break
	done

	if [ "$repeat" == 'true' ];then
		remove_backups
	fi
	if [ "$deleteBackup" == 'true' ];then
		delete_old_backup
	fi
}

delete_old_backup()
{
	local removedDirectories=$( ls $BACKUP_LOCATION )  directory=''

	echo $LINE
	if [ -n "$removedDirectories" ];then
		GET_PID=''
		echo -n "${S}Starting deletion of "
		for directory in $removedDirectories
		do
			echo -n "${C}$directory${S} "
		done
		echo -n "in ${C}$BACKUP_LOCATION${N}"
		echo
		echo -n "${S}This could take a while, be patient$ENDING_2${N}"
		if [ "$B_SPINNING_WHEEL" != 'true' ];then
			echo
			echo # clear that -n
		fi
		for directory in $removedDirectories
		do
			if [ "$B_SPINNING_WHEEL" == 'true' ];then
				rm -fr $BACKUP_LOCATION/$directory &
				GET_PID="$!"
				spinning_wheel_activity_indicator delete
				wait
			else
				echo -n "${S}Deleting ${C}$BACKUP_LOCATION/$directory${S} now.....${N}"
				rm -fr $BACKUP_LOCATION/$directory
				echo "${S}... directory deleted${N}"
			fi
		done
	else
		echo -n "${S}There is nothing to delete, continuing with backup...${N}"
	fi

	DELETION_TEXT=' deletion and'
	echo
	echo "${S}Starting backup now...${N}"
	sleep $SLEEP_TIME_BACKUP
	DELETE_STATUS='true'
}

run_backup_components()
{
	# set rdiff-backup/rsync commands. Must be here because delete data might be
	# set for rsync
	set_backup_commands

	# If you don't need excludes in /home, then just delete the exclude stuff, --exclude...
	echo $LINE

	#backup home directory
	if [ "$HOME_DIR" != '' -a "$B_SKIP_HOME" != 'true' ] || [ "$B_CLONE_HOME" == 'true' ];then
		echo -n "${S}$BACKUP_CLEAR ${C}home${S} directory$ENDING_1${N}"
		if [ "$B_SPINNING_WHEEL" == 'true' ];then
			GET_PID=''
			eval $HOME_BU_COMMAND &
			GET_PID="$!"
			spinning_wheel_activity_indicator backup home
		else
			eval $HOME_BU_COMMAND
			echo
		fi
		sleep $SLEEP_TIME_BACKUP
	fi

	# backup system root directory
	if [ "$ROOT_DIR" != '' -a "$B_SKIP_ROOT" != 'true'  ] || [ "$B_CLONE_ROOT" == 'true' ];then
		echo -n "${S}$BACKUP_CLEAR ${C}root${S} directory ${C}$ROOT_DESC${S}$ENDING_1${N}"
		if [ "$B_SPINNING_WHEEL" == 'true' ];then
			GET_PID=''
			eval $ROOT_BU_COMMAND &
			GET_PID="$!"
			spinning_wheel_activity_indicator backup $ROOT_DESC
		else
			eval $ROOT_BU_COMMAND
			echo
		fi
	fi

	if [ "$B_SKIP_DATA_FULL" != 'true' ];then
		# backup optional user data 1
		if [ "$DATA_1_DIR" != '' -a "$B_SKIP_DATA_1" != 'true' ];then
			echo -n "${S}$BACKUP_CLEAR${C}$DATA_1_DESC${S} directory$ENDING_1${N}"
			if [ "$B_SPINNING_WHEEL" == 'true' ];then
				GET_PID=''
				eval $DATA_1_BU_COMMAND &
				GET_PID="$!"
				spinning_wheel_activity_indicator backup $DATA_1_DESC
			else
				eval $DATA_1_BU_COMMAND
				echo
			fi
			sleep $SLEEP_TIME_BACKUP
		fi

		# backup optional user data 2
		if [ "$DATA_2_DIR" != '' -a "$B_SKIP_DATA_2" != 'true' ];then
			echo -n "${S}$BACKUP_CLEAR${C}$DATA_2_DESC${S} directory$ENDING_1${N}"
			if [ "$B_SPINNING_WHEEL" == 'true' ];then
				GET_PID=''
				eval $DATA_2_BU_COMMAND &
				GET_PID="$!"
				spinning_wheel_activity_indicator backup $DATA_2_DESC
			else
				eval $DATA_2_BU_COMMAND
				echo
			fi
			sleep $SLEEP_TIME_BACKUP
		fi

		# backup optional user data 3
		if [ "$DATA_3_DIR" != '' -a "$B_SKIP_DATA_3" != 'true' ];then
			echo -n "${S}$BACKUP_CLEAR${C}$DATA_3_DESC${S} directory$ENDING_1${N}"
			if [ "$B_SPINNING_WHEEL" == 'true' ];then
				GET_PID=''
				eval $DATA_3_BU_COMMAND &
				GET_PID="$!"
				spinning_wheel_activity_indicator backup $DATA_3_DESC
			else
				eval $DATA_3_BU_COMMAND
				echo
			fi
			sleep $SLEEP_TIME_BACKUP
		fi

		# backup optional user data 4
		if [ "$DATA_4_DIR" != '' -a "$B_SKIP_DATA_4" != 'true' ];then
			echo -n "${S}$BACKUP_CLEAR${C}$DATA_4_DESC${S} directory$ENDING_1${N}"
			if [ "$B_SPINNING_WHEEL" == 'true' ];then
				GET_PID=''
				eval $DATA_4_BU_COMMAND &
				GET_PID="$!"
				spinning_wheel_activity_indicator backup $DATA_4_DESC
			else
				eval $DATA_4_BU_COMMAND
				echo
			fi
			sleep $SLEEP_TIME_BACKUP
		fi

		# backup optional user data 5
		if [ "$DATA_5_DIR" != '' -a "$B_SKIP_DATA_5" != 'true' ];then
			echo -n "${S}$BACKUP_CLEAR${C}$DATA_5_DESC${S} directory$ENDING_1${N}"
			if [ "$B_SPINNING_WHEEL" == 'true' ];then
				GET_PID=''
				eval $DATA_5_BU_COMMAND &
				GET_PID="$!"
				spinning_wheel_activity_indicator backup $DATA_5_DESC
			else
				eval $DATA_5_BU_COMMAND
				echo
			fi
			sleep $SLEEP_TIME_BACKUP
		fi

		# backup optional user data 2
		if [ "$DATA_6_DIR" != '' -a "$B_SKIP_DATA_6" != 'true' ];then
			echo -n "${S}$BACKUP_CLEAR${C}$DATA_6_DESC${S} directory$ENDING_1${N}"
			if [ "$B_SPINNING_WHEEL" == 'true' ];then
				GET_PID=''
				eval $DATA_6_BU_COMMAND &
				GET_PID="$!"
				spinning_wheel_activity_indicator backup $DATA_6_DESC
			else
				eval $DATA_6_BU_COMMAND
				echo
			fi
			sleep $SLEEP_TIME_BACKUP
		fi

		# backup optional user data 7
		if [ "$DATA_7_DIR" != '' -a "$B_SKIP_DATA_7" != 'true' ];then
			echo -n "${S}$BACKUP_CLEAR${C}$DATA_7_DESC${S} directory$ENDING_1${N}"
			if [ "$B_SPINNING_WHEEL" == 'true' ];then
				GET_PID=''
				eval $DATA_7_BU_COMMAND &
				GET_PID="$!"
				spinning_wheel_activity_indicator backup $DATA_7_DESC
			else
				eval $DATA_7_BU_COMMAND
				echo
			fi
			sleep $SLEEP_TIME_BACKUP
		fi

		# backup optional user data 8
		if [ "$DATA_8_DIR" != '' -a "$B_SKIP_DATA_8" != 'true' ];then
			echo -n "${S}$BACKUP_CLEAR${C}$DATA_8_DESC${S} directory$ENDING_1${N}"
			if [ "$B_SPINNING_WHEEL" == 'true' ];then
				GET_PID=''
				eval $DATA_8_BU_COMMAND &
				GET_PID="$!"
				spinning_wheel_activity_indicator backup $DATA_8_DESC
			else
				eval $DATA_8_BU_COMMAND
				echo
			fi
			sleep $SLEEP_TIME_BACKUP
		fi

		# backup optional user data 9
		if [ "$DATA_9_DIR" != '' -a "$B_SKIP_DATA_9" != 'true' ];then
			echo -n "${S}$BACKUP_CLEAR${C}$DATA_9_DESC${S} directory$ENDING_1${N}"
			if [ "$B_SPINNING_WHEEL" == 'true' ];then
				GET_PID=''
				eval $DATA_9_BU_COMMAND &
				GET_PID="$!"
				spinning_wheel_activity_indicator backup $DATA_9_DESC
			else
				eval $DATA_9_BU_COMMAND
				echo
			fi
			sleep $SLEEP_TIME_BACKUP
		fi

		# backup optional user data 2
		if [ "$DATA_10_DIR" != '' -a "$B_SKIP_DATA_10" != 'true' ];then
			echo -n "${S}$BACKUP_CLEAR${C}$DATA_10_DESC${S} directory$ENDING_1${N}"
			if [ "$B_SPINNING_WHEEL" == 'true' ];then
				GET_PID=''
				eval $DATA_10_BU_COMMAND &
				GET_PID="$!"
				spinning_wheel_activity_indicator backup $DATA_10_DESC
			else
				eval $DATA_10_BU_COMMAND
				echo
			fi
			sleep $SLEEP_TIME_BACKUP
		fi
	fi
	# this is set to false either in the main rsync assigner or by rdiff feature
	if [ "$B_CLEAN_OLDER" != 'true' ];then
		finish_backup
	else
		echo $LINE
		echo "Ok, finished cleaning up older backup increments, running main backup now...${N}"
		sleep $SLEEP_TIME_BACKUP
	fi
}

#### -------------------------------------------------------------------
#### Backup completion functions
#### -------------------------------------------------------------------

finish_backup()
{
	# set the DURATION global here as well prior to updating configs
	print_the_end_time
	update_configs
	umount_backup_disk
	print_complete_message
}

update_configs()
{
	local backupDate=$( date +"%e %B %Y - %R" )
	local backupString="Location: $BACKUP_LOCATION :: Date: $backupDate~Completion time: $BACKUP_DURATION :: Deletion Used: $DELETE_STATUS :: Job No: $BACKUP_JOB_NU"

	echo $LINE
	echo "${S}Updating backup records now...${N}"
	sed -i "s%last-backup-directory=.*%last-backup-directory=$BACKUP_LOCATION%" $SCRIPT_CONFIGS
	sed -i "s/last-backup-date=.*/last-backup-date=$backupDate/" $SCRIPT_CONFIGS
	sed -i "s/last-backup-duration=.*/last-backup-duration=$BACKUP_DURATION/" $SCRIPT_CONFIGS
	sed -i "s/last-backup-app=.*/last-backup-app=$BACKUP_APP/" $SCRIPT_CONFIGS
	sed -i "s/last-backup-job=.*/last-backup-job=$BACKUP_JOB_NU/" $SCRIPT_CONFIGS

	case "$BACKUP_APP" in
		rdiff-backup)
			sed -i "s%rdbu-backup-history=.*%rdbu-backup-history=$backupString%" $SCRIPT_CONFIGS
			;;
		rsync)
			sed -i "s%rsync-backup-history=.*%rsync-backup-history=$backupString%" $SCRIPT_CONFIGS
			;;
	esac
}

# do some arithmetic on time
print_the_end_time()
{
	local endTime=$( date +%s )
	local completedTime=$(( $endTime - $START_TIME ))
	local hours=$(( $completedTime / 3600 ))
	local remainingMinutes=$(( $completedTime % 3600 ))
	local minutes=$(( $remainingMinutes / 60 ))
	local seconds=$(( $remainingMinutes % 60 ))
	local hourText='' minuteText='' secondText='' plural=''

	# set hours, if needed
	if [ "$hours" -ne 0 ];then
		if [ "$hours" -gt 1 ];then
			plural='s'
		else
			plural=''
		fi
		hourText=" ${C}$hours${S} hour$plural,"
	fi

	# set minutes
	if [ "$minutes" -gt 1 -o "$minutes" -eq 0 ];then
		plural='s'
	else
		plural=''
	fi
	minuteText=" ${C}$minutes${S} minute$plural,"

	# set seconds
	if [ "$seconds" -gt 1 -o "$seconds" -eq 0 ];then
		plural='s'
	else
		plural=''
	fi
	secondText=" ${C}$seconds${S} second$plural"

	echo "${S}The$DELETION_TEXT backup took$hourText$minuteText$secondText to complete.${N}"
	# zero pad the data
	minutes=$( printf %02d $minutes )
	seconds=$( printf %02d $seconds )
	BACKUP_DURATION=$hours:$minutes:$seconds
}

mount_backup_disk()
{
	local retNu=0

	if [ "$MOUNT_BU_DISK" != '' -a "$B_SKIP_MOUNT" != 'true'  ];then
		echo
		echo -n "${S}Mounting your backup drive/partition to $BACKUP_DIRECTORY now...${N}"
		eval $MOUNT_BU_DISK || retNu=$?
		if [ "$retNu" -eq 0 ];then
			echo "${S}.....successfully mounted.${N}"
		else
			echo "${S}.....${W}MOUNT FAILED!${N}"
			error_handler 2 "$retNu"
		fi
		# set the trap here
		trap 'trap_handler umount' INT TERM EXIT
	fi
}

umount_backup_disk()
{
	local retNu=0

	if [ "$MOUNT_BU_DISK" != '' -a "$B_SKIP_MOUNT" != 'true' ];then
		echo
		echo -n "${S}Unmounting your backup partition $BACKUP_DIRECTORY now...${N}"
		eval $UNMOUNT_BU_DISK || retNu=$?
		if [ "$retNu" -eq 0 ];then
			echo "${S}.....successfully unmounted.${N}"
		else
			echo "${S}.....${W}UNMOUNT FAILED!${N}"
			error_handler 3 "$retNu"
		fi
		trap - INT TERM EXIT
	fi
}

print_complete_message()
{
	echo $MLINE
	echo "${M}Ok, all done backing up for today"
	echo $MLINE
}

###################################################################
#####   EXECUTE SCRIPT COMPONENTS
###################################################################
get_options "$@"
# Make sure user is logged in as root first and that backup location is present
check_startup_stuff
# this sets the correct startup path so that exclude lists load correctly
check_script_path

# set rsync/rdiff-backup variables
set_primary_backup_data

# initialize the backup directory values
set_backup_directory_data

# then, if you use this, mount your backup drive
mount_backup_disk

# for option run deletion/run clean. You can only run one of these, not both.
if [ "$B_DELETE_BACKUP" == 'true' ];then
	delete_old_backup
	B_DO_BACKUP='true'
# this is for rdiff only, we need to run first the cleanup job, then
# next send it to the main backup.
elif [ "$B_CLEAN_OLDER" == 'true' -a "$BACKUP_TYPE" == 'rdiff-backup' ];then
	run_backup_components
	# must reset so we don't run the rdiff-cleanup stuff again
	B_CLEAN_OLDER='false'
	B_DO_BACKUP='true'
fi
# skip the intro question and do it automatically
if [ "$B_DO_BACKUP" == 'true' ];then
	run_backup_components
# otherwise ask what options to use
else
	run_backup_question
fi

## extra information:

#SpecialFileError var/run/acpid.socket Socket error: AF_UNIX path too long
#SpecialFileError var/run/dbus/system_bus_socket Socket error: AF_UNIX path too long
#SpecialFileError var/run/dirmngr/socket Socket error: AF_UNIX path too long
#SpecialFileError var/run/mysqld/mysqld.sock Socket error: AF_UNIX path too long
#SpecialFileError var/run/pcscd.comm Socket error: AF_UNIX path too long
#SpecialFileError var/run/xdmctl/dmctl/socket Socket error: AF_UNIX path too long
#SpecialFileError var/run/xdmctl/dmctl-:0/socket Socket error: AF_UNIX path too long

exit 0

###**EOF**###