#!/bin/bash
########################################################################
####  Script Name: rbxi
####  Version: 1.11.1
####  Date: 16 December 2008
####  Copyright (C) Harald Hope 2006-9
####
####  This program is free software; you can redistribute it and/or modify it under
####  the terms of the GNU General Public License as published by the Free Software
####  Foundation; either version 3 of the License, or (at your option) any later version.
####
####  This program is distributed in the hope that it will be useful, but WITHOUT
####  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
####  FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
####
####  Get the full text of the GPL here: http://www.gnu.org/licenses/gpl.txt
####
####  This is an rdiff-backup/rsync script which helps automate the backup process
####  Requires companion excludes-....txt files to run, those must be in the rbxi-data
####  directory
####
####  rbxi.tar.bz2 package download URL: http://smxi.org/rb [contains all needed files]
####  Script Home page: http://techpatterns.com/forums/about831.html
########################################################################

########################################################################
####  VARIABLES
####  Make sure to change these to fit your installation
########################################################################

########################################################################
####  LAYOUT VARIABLES
####--------------------------------------------------------------------
# colors
W="[1;31;40m" # red: Warning message
E="[1;33;40m" # yellow: script Error
S="[0;39m" # green: Standard message
Q="[1;36;40m" # CYAN: Questions
M="[1;36;40m" # CYAN: Message
# M="[1;34m" # BLUE: Message
C="[1;35;40m" # MAGENTA: Command or Path
B="[40m" # black background
N="[0;39m" # default system console color: Normal
# script layout stuff
BA='=================================================================='
LI='------------------------------------------------------------------'
BAR=${S}$BA${N}
EBAR=${E}$BA${N}
WBAR=${W}$BA${N}
MBAR=${M}$BA${N}
LINE=${S}$LI${N}
ELINE=${E}$LI${N}
MLINE=${M}$LI${N}
WLINE=${W}$LI${N}

########################################################################
####  USER SPECIFIC VARIABLES - REQUIRES rbxi-data/rbxi-values file
####--------------------------------------------------------------------

### See the file rbxi-data/rbxi-values for more complete instructions on now to
### set these variables. That file will be the actual data used, not this part
### which just initializes the variables. Script cannot run without the user data
### values file rbxi-data/rbxi-values

BACKUP_APP=''
BACKUP_DIRECTORY=''
BACKUP_DIRECTORY_RS=''
BACKUP_LOCATION=''
BACKUP_LOCATION_RS=''
BU_HOME=''
BU_ROOT=''
BU_DATA_1=''
BU_DATA_2=''
USER_HOME_PARENT=''
SYSTEM_ROOT=''
USER_DATA_1=''
USER_DATA_2=''
USER_DATA_1_DESC=''
USER_DATA_2_DESC=''
ROOT_DESC=''
RDIFF_EXTRA_OPTIONS=''
RSYNC_EXTRA_OPTIONS=''
SLEEP_TIME_BACKUP=''
SLEEP_TIME_SPINNER=''
MOUNT_BU_DISK=""
UNMOUNT_BU_DISK=""

# these are for options, used in case of cron or option run backups/deletes
B_DELETED=''
B_DO_BACKUP=''
B_SKIP_MOUNT=''
B_SPINNING_WHEEL=''
B_TESTING_1=''
B_TESTING_2=''

########################################################################
####  STATIC VARIABLES, SHOULD NOT REQUIRE CHANGES
####--------------------------------------------------------------------

### if you do need to change one of these, make sure to change it in the
### user values file: rbxi-data/rbxi-values, not here, or you might lose
### your changes if you update this script.

### Script names/paths
SCRIPT_CONFIGS='/etc/rbxi.conf'
SCRIPT_NAME='rbxi'
SCRIPT_VALUES='rbxi-values'
# http://forums.macosxhints.com/archive/index.php/t-73839.html
SCRIPT_PATH=$( dirname $( lsof -p $$ | grep 'REG' | grep -oE "/.*$(basename $0)$" ) )
SCRIPT_DATA_FILES="$SCRIPT_PATH/rbxi-data/"
SCRIPT_VERSION_NUMBER=$( grep -im 1 'version:' $SCRIPT_PATH/$SCRIPT_NAME | awk '{print $3}' )
SCRIPT_DOWNLOAD='http://rbxi.googlecode.com/svn/trunk/'
SCRIPT_DOWNLOAD_BRANCH_1='http://rbxi.googlecode.com/svn/branches/one/'
SCRIPT_DOWNLOAD_BRANCH_2='http://rbxi.googlecode.com/svn/branches/two/'
SCRIPT_DOWNLOAD_DEV='http://smxi.org/tests/'

#### EXCLUDE LIST FILE NAMES
# NOTE: can be a blank file, but most be located in same directory as rbxi
# if you want them in a different directory, use absolute system paths.
EXCLUDE_ROOT='excludes-root.txt'
EXCLUDE_HOME='excludes-home.txt'
EXCLUDE_DATA_1='excludes-data-1.txt'
EXCLUDE_DATA_2='excludes-data-2.txt'
EXCLUDE_ROOT_RS='excludes-root-rsync.txt'
EXCLUDE_HOME_RS='excludes-home-rsync.txt'
EXCLUDE_DATA_1_RS='excludes-data-1-rsync.txt'
EXCLUDE_DATA_2_RS='excludes-data-2-rsync.txt'

#### INITIALIZE VARIABLES TO BE SET ELSEWHERE
USER_HOME_BACKUP=''
ROOT_BACKUP=''

# these are optional, only used if BU_DATA_2 and BU_DATA_1 are set
USER_DATA_1_BACKUP=''
USER_DATA_2_BACKUP=''

# backup command string holders
HOME_BACKUP_COMMAND=''
ROOT_BACKUP_COMMAND=''
DATA_1_BACKUP_COMMAND=''
DATA_2_BACKUP_COMMAND=''

# set initial value
ENDING_1='...'
ENDING_2='...'
# for timer function
START_TIME=$( date +%s )

# internal script booleans
B_DELETE_BACKUP='false'
B_DELETE_OLDER='false'

# initialize globals to be set later
BACKUP_CLEAR=''
BACKUP_DURATION=''
DELETION_TEXT=''
# spinning wheel pid value
GET_PID=''
RSYNC_DELETE=''

## add in user variable values, sticky value file
if [ -f "$SCRIPT_DATA_FILES$SCRIPT_VALUES" ];then
	source $SCRIPT_DATA_FILES$SCRIPT_VALUES
else
	echo "${W}User Values File $SCRIPT_DATA_FILES$SCRIPT_VALUES is missing. Exiting now.${N}"
	exit 1
fi

###################################################################
#####  Functions
###################################################################

#### -------------------------------------------------------------------
#### Utilities
#### -------------------------------------------------------------------

# Error handling
# args: $1 - error number; $2 - optional, extra information
error_handler()
{
	local error_message=''

	# assemble the error message
	case $1 in
		2)	error_message="The component: MOUNT_BU_DISK failed to successfully complete its task. Error code was: $2"
			;;
		3)	error_message="The component: UNMOUNT_BU_DISK failed to successfully complete its task. Error code was: $2"
			;;
		4)	error_message="You must be logged in as root to run this script."
			;;
		5)	error_message="dependency not met: $2 not found in path"
			;;
		6)	error_message="Your backup partition/directory ${C}$BACKUP_DIRECTORY${E} is not present.\nPlease make sure to create it or mount it up before you proceed."
			;;
		7)	error_message="One of the options you entered in your script parameters: $2\nIs not supported. For supported options, check the help menu: $SCRIPT_NAME -h"
			;;
		8)	error_message="the self-updater failed, wget exited with error: $2.\nYou probably need to be root.\nHint, to make for easy updates without being root, do: chown <user name> $SCRIPT_PATH/$SCRIPT_NAME"
			;;
		9)	error_message="missing the required script directory: $2"
			;;
		10)
			error_message="the alt download url you provided: $2\nappears to be wrong, download aborted. Please note, the url\nneeds to end in /, without $SCRIPT_NAME, like: http://yoursite.com/downloads/"
			;;
		11)
			error_message="unsupported testing option argument: -! $2"
			;;
		12)
			error_message="the svn branch download url: $2\nappears to be empty currently. Make sure there is an actual svn branch version\nactive before you try this again. Check http://code.google.com/p/inxi\nto verify the branch status."
			;;
		13)
			error_message="The option argument you gave is not supported: $2"
			;;
		14)
			error_message="You do not have the required backup application installed. Missing: $2"
			;;
		50)
			error_message="User initiated script exit. Shutting down now."
			;;
		100)
			error_message="$SCRIPT_NAME does not yet support the backup app you requested: $2\nThis support should be coming sometime soon.\nCurrently supported backup applications are: rdiff-backup."
			unmount_backup_disk
			;;
		*)	error_message="Unknown error number: $1"
			;;
	esac
	# then print it and exit
	echo -e "${W}Error $1: $error_message${N}"
	exit $1
}

print_usage()
{
	if [ "$1" == 'err' ];then
		echo 'You entered an invalid option. Please use one of the following only:'
	fi
	echo '-b Automatic backup, no questions.'
	echo '-d Automatic backup and delete, no questions.'
	echo "-L Create symbolic link in /usr/local/bin to $SCRIPT_NAME"
	echo '-m Skip the mounting option.'
	echo '-o Override default backup application."
	echo "   Requires argument: rs for rsync; rd for rdiff-backup'
	echo '-s Show spinning wheel indicator.'
	echo '-U Update script manually from svn server.'
	echo '-v Show script version and last used information.'
	echo '-h This help menu'
	exit 0
}

### this is not in a function because these variables need to be set on startup
# only use b or d, not both together. If you use both your old backups will be deleted.
# args: $1 - $@ - all args
get_options()
{
	local opt=''

	while getopts :bdhLmo:sUv!: opt
	do
		case $opt in
			h)	print_usage
				;;
			b)	B_DO_BACKUP='true'
				;;
			d)	B_DELETE_BACKUP='true'
				;;
			L) create_symbolic_link
				exit 0
				;;
			m)	B_SKIP_MOUNT='true'
				;;
			o)	if [ -n "$( egrep '^(rd|rs)$' <<< $OPTARG )" ];then
					case $OPTARG in
						rd)
							BACKUP_APP='rdiff-backup'
							;;
						rs)
							BACKUP_APP='rsync'
							;;
					esac
				else
					error_handler 13 "-$opt $OPTARG"
				fi
				;;
			s)	B_SPINNING_WHEEL='true'
				ENDING_1=': '
				ENDING_2=', watch the spinning wheel: '
				;;
			U)	script_self_updater "$SCRIPT_DOWNLOAD" 'svn server'
				;;
			v)	print_version_info
				exit 0
				;;
			!)	# test for various supported methods
				case $OPTARG in
					1)	B_TESTING_1='true'
						;;
					2)	B_TESTING_2='true'
						;;
					3)	B_TESTING_1='true'
						B_TESTING_2='true'
						;;
					10) script_self_updater "$SCRIPT_DOWNLOAD_DEV" 'dev server'
						;;
					11)	script_self_updater "$SCRIPT_DOWNLOAD_BRANCH_1" 'svn: branch one server'
						;;
					12)	script_self_updater "$SCRIPT_DOWNLOAD_BRANCH_2" 'svn: branch two server'
						;;
					http*)
						script_self_updater "$OPTARG" 'alt server'
						;;
					*)	error_handler 11 "$OPTARG"
						;;
				esac
				;;
			*)	error_handler 7 "$1"
				;;
		esac
	done
}

## print out version information for -v
print_version_info()
{
	local last_modified=$( grep -im 1 'date:' $SCRIPT_PATH/$SCRIPT_NAME | gawk '{print $3,$4,$5}' )

	echo "$SCRIPT_NAME - the universal, portable, system backup script."
	echo "Version: $SCRIPT_VERSION_NUMBER"
	echo "Script Last Modified: $last_modified"
	echo "Script Location: $SCRIPT_PATH${N}"
	print_history_data
}

# args: $1 - main/v
print_history_data()
{
	local lastBackupDirectory='Unset'
	local lastBackupDate='Unset'
	local lastBackupDuration='Unset'
	local lastBackupApp='Unset'
	local rdbuHistory='Unset'
	local rsyncHistory='Unset'

	if [ -f $SCRIPT_CONFIGS ];then
		lastBackupDirectory=$( grep 'last-backup-directory=' $SCRIPT_CONFIGS | cut -d '=' -f 2 )
		lastBackupDate=$( grep 'last-backup-date=' $SCRIPT_CONFIGS | cut -d '=' -f 2 )
		lastBackupDuration=$( grep 'last-backup-duration=' $SCRIPT_CONFIGS | cut -d '=' -f 2 )
		lastBackupApp=$( grep 'last-backup-app=' $SCRIPT_CONFIGS | cut -d '=' -f 2 )
		# add line breaks because output is too long for single line
		rdbuHistory="$( grep 'rdbu-backup-history=' $SCRIPT_CONFIGS | cut -d '=' -f 2 | tr '~' '\n' )"
		rsyncHistory="$( grep 'rsync-backup-history=' $SCRIPT_CONFIGS | cut -d '=' -f 2 | tr '~' '\n' )"
	fi
	echo "${S}Last Backup Date: $lastBackupDate${N}"
	echo "${S}Last Backup Directory: $lastBackupDirectory${N}"
	echo "${S}Last Backup Program: $lastBackupApp${N}"
	if [ "$1" == 'main' ];then
		case "$BACKUP_APP" in
			rdiff-backup)
				echo -e "${S}Rdiff-backup history: $rdbuHistory${N}"
				;;
			rsync)
				echo -e "${S}Rsync backup history: $rsyncHistory${N}"
				;;
		esac
	else
		echo -e "${S}Rdiff-backup history: $rdbuHistory${N}"
		echo -e "${S}Rsync backup history: $rsyncHistory${N}"
	fi
}

# args: $1 - download url, not including file name; $2 - string to print out
# note that $1 must end in / to properly construct the url path
script_self_updater()
{
	local wget_error=0

	echo "Starting $SCRIPT_NAME self updater."
	echo "Currently running $SCRIPT_NAME version number: $SCRIPT_VERSION_NUMBER"
	echo "Updating $SCRIPT_NAME in $SCRIPT_PATH using $2 as download source..."
	# first test if path is good, need to make sure it's good because we're -O overwriting file
	wget -q --spider $1$SCRIPT_NAME || wget_error=$?
	# then do the actual download
	if [[ $wget_error -eq 0 ]];then
		wget -q -O $SCRIPT_PATH/$SCRIPT_NAME $1$SCRIPT_NAME || wget_error=$?
		if [[ $wget_error -eq 0 ]];then
			SCRIPT_VERSION_NUMBER=$( grep -im 1 'version:' $SCRIPT_PATH/$SCRIPT_NAME | awk '{print $3}' )
			echo "Successfully updated to $2 version: $SCRIPT_VERSION_NUMBER"
			echo "To run the new version, just start $SCRIPT_NAME again."
			exit 0
		fi
	fi
	# now run the error handlers on any wget failure
	if [[ $wget_error -gt 0 ]];then
		if [[ $2 == 'svn server' ]];then
			error_handler 8 "$wget_error"
		elif [[ $2 == 'alt server' ]];then
			error_handler 10 "$1"
		else
			error_handler 12 "$1"
		fi
	fi
}

# creates the spinning wheel if script starts with -s option, and shows completion
spinning_wheel_activity_indicator()
{
	local completionText=''

	if [ "$1" == 'delete' ];then
		completionText='backup directories removed'
	fi
	if [ "$1" == 'backup' ];then
		completionText="$2 backed up"
	fi

	echo -n ${S}
	# while kill -0 $GET_PID
	while [ -e /proc/$GET_PID ]
	do
		sleep $SLEEP_TIME_SPINNER
		echo -n '|'
		echo -ne "\b"
		sleep $SLEEP_TIME_SPINNER
		echo -n '/'
		echo -ne "\b"
		sleep $SLEEP_TIME_SPINNER
		echo -n '-'
		echo -ne "\b"
		sleep $SLEEP_TIME_SPINNER
		echo -n "\\"
		echo -ne "\b"
	done
	echo -ne "\b $completionText"
	echo ${N}
}

# args: $1 umount/
trap_handler()
{
 	case "$1" in
 		umount)
 			echo "${S}Waiting a few seconds to let disk writes sync before exiting...${N}"
 			sleep 5 # give the disk time to demount...
 			unmount_backup_disk
 			# set trap to null to avoid loops for final exits
			trap - INT TERM EXIT
 			error_handler 50
 			;;
 	esac
}

#### -------------------------------------------------------------------
#### basic tests
#### -------------------------------------------------------------------

check_startup_stuff()
{
	check_root
	create_etc_configs
	if [ ! -d $BACKUP_DIRECTORY ];then
		error_handler 9 $BACKUP_DIRECTORY
	fi
	check_bu_app_installed
}

check_root()
{
	if [ "$( whoami )" != "root" ];then
		error_handler 4
	fi
}

set_path()
{
	local ExDir=$( dirname $0 )

	if [ "$( pwd )" != "$ExDir" -a "$ExDir" != '.' ];then
		cd $ExDir
	fi
}

check_bu_app_installed()
{
	if [ -z "$( which $BACKUP_APP )" ];then
		error_handler 14 $BACKUP_APP
	fi
}

create_etc_configs()
{
	if [ ! -f $SCRIPT_CONFIGS ];then
		touch $SCRIPT_CONFIGS
		echo 'last-backup-directory=Unset' >> $SCRIPT_CONFIGS
		echo 'last-backup-date=Unset' >> $SCRIPT_CONFIGS
		echo 'last-backup-duration=Unset' >> $SCRIPT_CONFIGS
	fi
	if [ -z "$( grep 'rdbu-backup-history=' $SCRIPT_CONFIGS )" ];then
		echo 'rdbu-backup-history=Unset' >> $SCRIPT_CONFIGS
	fi
	if [ -z "$( grep 'rsync-backup-history=' $SCRIPT_CONFIGS )" ];then
		echo 'rsync-backup-history=Unset' >> $SCRIPT_CONFIGS
	fi
	if [ -z "$( grep 'last-backup-app=' $SCRIPT_CONFIGS )" ];then
		echo 'last-backup-app=Unset' >> $SCRIPT_CONFIGS
	fi
}

create_symbolic_link()
{
	local ulbLink="/usr/local/bin/$SCRIPT_NAME"
	local scriptInPath=$( which $SCRIPT_NAME | grep -v "./$SCRIPT_NAME" )

	if [ ! -L $ulbLink -a ! -f $ulbLink -a -z "$scriptInPath" ];then
		check_root
		echo "${S}Creating link now...${N}"
		ln -s $SCRIPT_PATH/$SCRIPT_NAME $ulbLink
	else
		echo "${S}$SCRIPT_NAME is already in your system path, or a link to it already exists.${N}"
	fi
}

#### -------------------------------------------------------------------
#### primary backup tools
#### -------------------------------------------------------------------

# load proper values for locations and command strings
set_primary_backup_data()
{
	case "$BACKUP_APP" in
		rsync)
			# update global file names
			BACKUP_LOCATION=$BACKUP_DIRECTORY_RS$BACKUP_LOCATION_RS
			EXCLUDE_ROOT=$EXCLUDE_ROOT_RS
			EXCLUDE_HOME=$EXCLUDE_HOME_RS
			EXCLUDE_DATA_1=$EXCLUDE_DATA_1_RS
			EXCLUDE_DATA_2=$EXCLUDE_DATA_2_RS
			MOUNT_BU_DISK=$MOUNT_BU_DISK_RS
			UNMOUNT_BU_DISK=$UNMOUNT_BU_DISK_RS
			;;
		rdiff-backup)
			BACKUP_LOCATION=$BACKUP_DIRECTORY$BACKUP_LOCATION
			;;
	esac
}

# create backup directory then set backup directory names
set_backup_directory_data()
{
	local month=$( date +%m )

	echo $LINE
	echo "${S}Working backup location: ${C}$BACKUP_LOCATION${N}"

	# make sure it exists
	if [ ! -d "$BACKUP_LOCATION" ];then
		mkdir $BACKUP_LOCATION
	fi

	# assemble the backup paths
	if [ "$BU_HOME" != '' ];then
		USER_HOME_BACKUP=$BACKUP_LOCATION/$BU_HOME
	fi
	if [ "$BU_ROOT" != '' ];then
		ROOT_BACKUP=$BACKUP_LOCATION/$BU_ROOT
	fi
	if [ "$BU_DATA_1" != '' ];then
		USER_DATA_1_BACKUP=$BACKUP_LOCATION/$BU_DATA_1
	fi
	if [ "$BU_DATA_2" != '' ];then
		USER_DATA_2_BACKUP=$BACKUP_LOCATION/$BU_DATA_2
	fi
}

set_backup_commands()
{
	case "$BACKUP_APP" in
		rsync)
			# set commands
			HOME_BACKUP_COMMAND="rsync -a --exclude-from=$SCRIPT_DATA_FILES$EXCLUDE_HOME $RSYNC_DELETE $RSYNC_EXTRA_OPTIONS $USER_HOME_PARENT $USER_HOME_BACKUP"
			ROOT_BACKUP_COMMAND="rsync -a --exclude-from=$SCRIPT_DATA_FILES$EXCLUDE_ROOT $RSYNC_DELETE $RSYNC_EXTRA_OPTIONS $SYSTEM_ROOT $ROOT_BACKUP"
			DATA_1_BACKUP_COMMAND="rsync -a --exclude-from=$SCRIPT_DATA_FILES$EXCLUDE_DATA_1 $RSYNC_DELETE $RSYNC_EXTRA_OPTIONS $USER_DATA_1 $USER_DATA_1_BACKUP"
			DATA_2_BACKUP_COMMAND="rsync -a --exclude-from=$SCRIPT_DATA_FILES$EXCLUDE_DATA_2 $RSYNC_DELETE $RSYNC_EXTRA_OPTIONS $USER_DATA_2 $USER_DATA_2_BACKUP"
			# set text
			BACKUP_CLEAR='Backing up'
			;;
		rdiff-backup)
			# set commands
			# http://www.mail-archive.com/rdiff-backup-users@nongnu.org/msg01212.html
			# --exclude-sockets to get rid of that dumb socket error
			if [ "$B_DELETE_OLDER" != 'true' ];then
				# set commands
				HOME_BACKUP_COMMAND="rdiff-backup --exclude-sockets --exclude-globbing-filelist $SCRIPT_DATA_FILES$EXCLUDE_HOME $RDIFF_EXTRA_OPTIONS $USER_HOME_PARENT $USER_HOME_BACKUP"
				ROOT_BACKUP_COMMAND="rdiff-backup --exclude-sockets --exclude-globbing-filelist $SCRIPT_DATA_FILES$EXCLUDE_ROOT $RDIFF_EXTRA_OPTIONS $SYSTEM_ROOT $ROOT_BACKUP"
				DATA_1_BACKUP_COMMAND="rdiff-backup --exclude-sockets --exclude-globbing-filelist $SCRIPT_DATA_FILES$EXCLUDE_DATA_1 $RDIFF_EXTRA_OPTIONS $USER_DATA_1 $USER_DATA_1_BACKUP"
				DATA_2_BACKUP_COMMAND="rdiff-backup --exclude-sockets --exclude-globbing-filelist $SCRIPT_DATA_FILES$EXCLUDE_DATA_2 $RDIFF_EXTRA_OPTIONS $USER_DATA_2 $USER_DATA_2_BACKUP"
				# set text
				BACKUP_CLEAR='Backing up'
			else
				# set commands
				HOME_BACKUP_COMMAND="rdiff-backup --force --remove-older-than $RDIFF_REMOVE_TIME $USER_HOME_BACKUP"
				ROOT_BACKUP_COMMAND="rdiff-backup --force --remove-older-than $RDIFF_REMOVE_TIME $ROOT_BACKUP"
				DATA_1_BACKUP_COMMAND="rdiff-backup --force --remove-older-than $RDIFF_REMOVE_TIME $USER_DATA_1_BACKUP"
				DATA_2_BACKUP_COMMAND="rdiff-backup --force --remove-older-than $RDIFF_REMOVE_TIME $USER_DATA_2_BACKUP"
				# set text
				BACKUP_CLEAR="Removing all increments older than $RDIFF_REMOVE_TIME from"
			fi
			;;
	esac
}

run_backup_question()
{
	local opt='' options='' doTheBackup='' removeBackup='' repeat=''
	local removeDeleteOpt=''

	echo $MLINE
	print_history_data 'main'
	echo $MLINE
	case "$BACKUP_APP" in
		rdiff-backup)
			echo "${S}Backups use standard $BACKUP_APP settings, which lets you restore from any time"
			echo "period stored in the full backup. After first full backup, the next ones will be"
			echo "incremental backups, which run much faster since they only backup changed files."
			;;
		rsync)
			echo "${S}This will backup your system to the backup directories you have already set up"
			echo "for your $BACKUP_APP backup."
			;;
	esac
	echo $LINE
	echo "${S}Please select one of the following numbers to assign the correct backup option."
	echo "1 - backs up as usual with $BACKUP_APP. Does not remove old backups."
	case "$BACKUP_APP" in
		rdiff-backup)
			echo "2 - remove-older - Removes all backup increments older than your time setting: $RDIFF_REMOVE_TIME"
			echo "    After the cleanup, runs a new standard backup."
			removeDeleteOpt='remove-older'
			;;
		rsync)
			echo "2 - delete-obsolete - Removes all backed up up files that have been deleted from"
			echo "    your current install."
			removeDeleteOpt='delete-obsolete'
			;;
	esac
	echo "3 - backs up but first deletes old backups. This is final, so once you agree to"
	echo "    remove, no restore of older material will be possible. This will delete the"
	echo "    backup that corresponds to the currently active primary backup directory."
	echo
	echo "4 - Quit, don't do the backup after all."
	echo $LINE
	options="backup-normal $removeDeleteOpt backup-and-delete-old quit"
	select opt in $options
	do
		case $opt in
			backup-normal)
				doTheBackup='true'
				;;
			backup-and-delete-old)
				removeBackup='true'
				doTheBackup='true'
				;;
			remove-older)
				# first get rid of all older files and increments
				B_DELETE_OLDER='true'
				run_backup_components
				B_DELETE_OLDER='false'
				doTheBackup='true'
				;;
			delete-obsolete)
				RSYNC_DELETE=' --delete --delete-excluded '
				doTheBackup='true'
				;;
			quit)
				echo "${S}Ok, no backup today, exiting the script...${N}"
				exit 0
				;;
			*)
				echo $ELINE
				echo "${E}You need to type in one of above the numbers!!${N}"
				repeat='true'
				;;
		esac
		break
	done

	if [ "$repeat" == 'true' ];then
		run_backup_question
	fi
	if [ "$removeBackup" == 'true' ];then
		remove_backups
	fi
	if [ "$doTheBackup" == 'true' ];then
		run_backup_components
	fi
}

remove_backups()
{
	local options='' opt='' repeat='' deleteBackup=''

	echo $LINE
	echo "${Q}Are you sure you want to delete the contents of your backup directories?${N}"
	echo "${S}[Type in the appropriate number and hit enter]"
	echo $LINE
	options='yes-delete no-keep quit'
	select opt in $options
	do
		case $opt in
			yes-delete)
				deleteBackup='true'
				;;
			no-keep)
				echo $LINE
				echo "${S}Ok, no deleting of them today."
				echo
				echo "Continuing with backup now...${N}"
				;;
			quit)
				echo "${S}Ok, no backup today, exiting the script...${N}"
				exit 0
				;;
			*)
				echo $ELINE
				echo "${E}You need to type in one of above the numbers!!${N}"
				repeat='true'
				;;
		esac
		break
	done

	if [ "$repeat" == 'true' ];then
		remove_backups
	fi
	if [ "$deleteBackup" == 'true' ];then
		delete_old_backup
	fi
}

delete_old_backup()
{
	local removedDirectories=$( ls $BACKUP_LOCATION )  directory=''
	GET_PID=''

	echo $LINE
	echo -n "${S}Deleting "
	for directory in $removedDirectories
	do
		echo -n "${C}$directory${S} "
	done
	echo -n "in ${C}$BACKUP_LOCATION${N}"
	echo
	echo -n "${S}This could take a while, be patient$ENDING_2${N}"
	if [ "$B_SPINNING_WHEEL" == 'true' ];then
		rm -fr $BACKUP_LOCATION/* &
		GET_PID="$!"
		spinning_wheel_activity_indicator delete
		wait
	else
		rm -fr $BACKUP_LOCATION/*
		echo "${S}Backup directories removed."
	fi
	DELETION_TEXT=' deletion and'
	echo
	echo "Starting backup now${N}"

	B_DELETED='true'
}

run_backup_components()
{
	# set rdiff-backup/rsync commands. Must be here because delete data might be
	# set for rsync
	set_backup_commands

	# If you don't need excludes in /home, then just delete the exclude stuff, --exclude...
	echo $LINE

# 	if [ "$BACKUP_APP" == 'rsync' -a "$B_TESTING_1" != 'true' ];then
# 		error_handler 100 $BACKUP_APP
# 	fi
	if [ "$B_TESTING_1" != 'true' ];then

	#backup home directory
	# backup optional user data 1
	if [ "$BU_HOME" != '' ];then
		echo -n "${S}$BACKUP_CLEAR ${C}home${S} directory$ENDING_1${N}"
		if [ "$B_SPINNING_WHEEL" == 'true' ];then
			GET_PID=''
			eval $HOME_BACKUP_COMMAND &
			GET_PID="$!"
			spinning_wheel_activity_indicator backup home
		else
			eval $HOME_BACKUP_COMMAND
			echo
		fi
		sleep $SLEEP_TIME_BACKUP
	fi

	# backup optional user data 1
	if [ "$BU_DATA_1" != '' ];then
		echo -n "${S}$BACKUP_CLEAR${C}$USER_DATA_1_DESC${S} directory$ENDING_1${N}"
		if [ "$B_SPINNING_WHEEL" == 'true' ];then
			GET_PID=''
			eval $DATA_1_BACKUP_COMMAND &
			GET_PID="$!"
			spinning_wheel_activity_indicator backup $USER_DATA_1_DESC
		else
			eval $DATA_1_BACKUP_COMMAND
			echo
		fi
		sleep $SLEEP_TIME_BACKUP
	fi

	# backup optional user data 2
	if [ "$BU_DATA_2" != '' ];then
		echo -n "${S}$BACKUP_CLEAR${C}$USER_DATA_2_DESC${S} directory$ENDING_1${N}"
		if [ "$B_SPINNING_WHEEL" == 'true' ];then
			GET_PID=''
			eval $DATA_2_BACKUP_COMMAND &
			GET_PID="$!"
			spinning_wheel_activity_indicator backup $USER_DATA_2_DESC
		else
			eval $DATA_2_BACKUP_COMMAND
			echo
		fi
		sleep $SLEEP_TIME_BACKUP
	fi

	fi # test end
	# backup system root directory
	# backup optional user data 1
	if [ "$BU_ROOT" != '' ];then
		echo -n "${S}$BACKUP_CLEAR ${C}root${S} directory ${C}$ROOT_DESC${S}$ENDING_1${N}"
		if [ "$B_SPINNING_WHEEL" == 'true' ];then
			GET_PID=''
			eval $ROOT_BACKUP_COMMAND &
			GET_PID="$!"
			spinning_wheel_activity_indicator backup $ROOT_DESC
		else
			eval $ROOT_BACKUP_COMMAND
			echo
		fi
	fi
	if [ "$B_DELETE_OLDER" != 'true' ];then
		finish_backup
	else
		echo $LINE
		echo "Ok, finished cleaning up older backup increments, running main backup now...${N}"
		sleep $SLEEP_TIME_BACKUP
	fi
}

finish_backup()
{
	# set the DURATION global here as well prior to updating configs
	print_the_end_time
	update_configs
	unmount_backup_disk
	print_complete_message
}

update_configs()
{
	local backupDate=$( date +"%e %B %Y - %R" )
	local backupString="Location: $BACKUP_LOCATION :: Date: $backupDate~\t\t\tCompletion time: $BACKUP_DURATION :: Deletion Used: $B_DELETED"

	echo $LINE
	echo "${S}Updating backup records now...${N}"
	sed -i "s%last-backup-directory=.*%last-backup-directory=$BACKUP_LOCATION%" $SCRIPT_CONFIGS
	sed -i "s/last-backup-date=.*/last-backup-date=$backupDate/" $SCRIPT_CONFIGS
	sed -i "s/last-backup-duration=.*/last-backup-duration=$BACKUP_DURATION/" $SCRIPT_CONFIGS
	sed -i "s/last-backup-app=.*/last-backup-app=$BACKUP_APP/" $SCRIPT_CONFIGS

	case "$BACKUP_APP" in
		rdiff-backup)
			sed -i "s%rdbu-backup-history=.*%rdbu-backup-history=$backupString%" $SCRIPT_CONFIGS
			;;
		rsync)
			sed -i "s%rsync-backup-history=.*%rsync-backup-history=$backupString%" $SCRIPT_CONFIGS
			;;
	esac
}

# do some arithmetic on time
print_the_end_time()
{
	local endTime=$( date +%s )
	local completedTime=$(( $endTime - $START_TIME ))
	local hours=$(( $completedTime / 3600 ))
	local remainingMinutes=$(( $completedTime % 3600 ))
	local minutes=$(( $remainingMinutes / 60 ))
	local seconds=$(( $remainingMinutes % 60 ))
	local hourText='' minuteText='' secondText='' plural=''

	# set hours, if needed
	if [ "$hours" -ne 0 ];then
		if [ "$hours" -gt 1 ];then
			plural='s'
		else
			plural=''
		fi
		hourText=" ${C}$hours${S} hour$plural,"
	fi

	# set minutes
	if [ "$minutes" -gt 1 -o "$minutes" -eq 0 ];then
		plural='s'
	else
		plural=''
	fi
	minuteText=" ${C}$minutes${S} minute$plural,"

	# set seconds
	if [ "$seconds" -gt 1 -o "$seconds" -eq 0 ];then
		plural='s'
	else
		plural=''
	fi
	secondText=" ${C}$seconds${S} second$plural"

	echo "${S}The$DELETION_TEXT backup took$hourText$minuteText$secondText to complete.${N}"
	# zero pad the data
	minutes=$( printf %02d $minutes )
	seconds=$( printf %02d $seconds )
	BACKUP_DURATION=$hours:$minutes:$seconds
}

mount_backup_disk()
{
	local retNu=0

	if [ "$MOUNT_BU_DISK" != '' -a "$B_SKIP_MOUNT" != 'true'  ];then
		echo
		echo -n "${S}Mounting your backup drive/partition to $BACKUP_DIRECTORY now...${N}"
		eval $MOUNT_BU_DISK || retNu=$?
		if [ "$retNu" -eq 0 ];then
			echo "${S}.....successfully mounted.${N}"
		else
			echo "${S}.....${W}MOUNT FAILED!${N}"
			error_handler 2 "$retNu"
		fi
	fi
	# set the trap here
	trap 'trap_handler umount' INT TERM EXIT
}

unmount_backup_disk()
{
	local retNu=0

	if [ "$MOUNT_BU_DISK" != '' -a "$B_SKIP_MOUNT" != 'true' ];then
		echo
		echo -n "${S}Unmounting your backup partition $BACKUP_DIRECTORY now...${N}"
		eval $UNMOUNT_BU_DISK || retNu=$?
		if [ "$retNu" -eq 0 ];then
			echo "${S}.....successfully unmounted.${N}"
		else
			echo "${S}.....${W}UNMOUNT FAILED!${N}"
			error_handler 3 "$retNu"
		fi
	fi
	trap - INT TERM EXIT
}

print_complete_message()
{
	echo $MLINE
	echo "${M}Ok, all done backing up for today"
	echo $MLINE
}

###################################################################
#####   EXECUTE SCRIPT COMPONENTS
###################################################################
get_options "$@"
# Make sure user is logged in as root first and that backup location is present
check_startup_stuff
# this sets the correct startup path so that exclude lists load correctly
set_path

# set rsync/rdiff-backup variables
set_primary_backup_data

# then, if you use this, mount your backup drive
mount_backup_disk

# initialize the backup directory values
set_backup_directory_data

# for option run deletion
if [ "$B_DELETE_BACKUP" == 'true' ];then
	delete_old_backup
fi

# skip the intro question and do it automatically
if [ "$B_DO_BACKUP" == 'true' -o "$B_DELETE_BACKUP" == 'true' ];then
	run_backup_components
# otherwise ask what options to use
else
	run_backup_question
fi

## extra information:

#SpecialFileError var/run/acpid.socket Socket error: AF_UNIX path too long
#SpecialFileError var/run/dbus/system_bus_socket Socket error: AF_UNIX path too long
#SpecialFileError var/run/dirmngr/socket Socket error: AF_UNIX path too long
#SpecialFileError var/run/mysqld/mysqld.sock Socket error: AF_UNIX path too long
#SpecialFileError var/run/pcscd.comm Socket error: AF_UNIX path too long
#SpecialFileError var/run/xdmctl/dmctl/socket Socket error: AF_UNIX path too long
#SpecialFileError var/run/xdmctl/dmctl-:0/socket Socket error: AF_UNIX path too long

exit 0
###**EOF**###