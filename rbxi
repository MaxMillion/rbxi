#!/bin/bash
########################################################################
####  Script Name: rbxi
####  Version: 1.9.1
####  Date: 13 December 2008
####  Copyright (C) Harald Hope 2006-9
####
####  This program is free software; you can redistribute it and/or modify it under
####  the terms of the GNU General Public License as published by the Free Software
####  Foundation; either version 3 of the License, or (at your option) any later version.
####
####  This program is distributed in the hope that it will be useful, but WITHOUT
####  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
####  FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
####
####  Get the full text of the GPL here: http://www.gnu.org/licenses/gpl.txt
####
####  This is an rdiff-backup/rsync script which helps automate the backup process
####  Requires companion excludes.txt files to run, those must be in the rbxi-data
####  directory
####
####  bu.tar.bz2 package download URL: http://techpatterns.com/rbxi [contains all needed files]
####  Script Home page: http://techpatterns.com/forums/about831.html
########################################################################

########################################################################
####  VARIABLES
####  Make sure to change these to fit your installation
########################################################################

########################################################################
####  LAYOUT VARIABLES
####--------------------------------------------------------------------
# colors
W="[1;31;40m" # red: Warning message
E="[1;33;40m" # yellow: script Error
S="[0;39m" # green: Standard message
Q="[1;36;40m" # CYAN: Questions
M="[1;36;40m" # CYAN: Message
# M="[1;34m" # BLUE: Message
C="[1;35;40m" # MAGENTA: Command or Path
B="[40m" # black background
N="[0;39m" # default system console color: Normal
# script layout stuff
BA='=================================================================='
LI='------------------------------------------------------------------'
BAR=${S}$BA${N}
EBAR=${E}$BA${N}
WBAR=${W}$BA${N}
MBAR=${M}$BA${N}
LINE=${S}$LI${N}
ELINE=${E}$LI${N}
MLINE=${M}$LI${N}
WLINE=${W}$LI${N}

########################################################################
####  USER SPECIFIC VARIABLES - REQUIRES rbxi-data/rbxi-values file
####--------------------------------------------------------------------

### See the file rbxi-data/rbxi-values for more complete instructions on now to
### set these variables. That file will be the actual data used, not this part
### which just initializes the variables. Script cannot run without the user data
### values file rbxi-data/rbxi-values

BACKUP_APP=''
BACKUP_DIRECTORY=''
BACKUP_LOCATION=''
BU_HOME=''
BU_ROOT=''
BU_DATA_1=''
BU_DATA_2=''
USER_HOME_PARENT=''
SYSTEM_ROOT=''
USER_DATA_1=''
USER_DATA_2=''
USER_DATA_1_DESC=''
USER_DATA_2_DESC=''
ROOT_PARTITION=''
SLEEP_TIME=''
MOUNT_BU_DISK=""
UNMOUNT_BU_DISK=""

########################################################################
####  STATIC VARIABLES, SHOULD NOT REQUIRE CHANGES
####--------------------------------------------------------------------

### if you do need to change one of these, make sure to change it in the
### user values file: rbxi-data/rbxi-values, not here, or you might lose
### your changes if you update this script.

### Script names/paths
SCRIPT_CONFIGS='/etc/rbxi.conf'
SCRIPT_NAME='rbxi'
SCRIPT_VALUES='rbxi-values'
# http://forums.macosxhints.com/archive/index.php/t-73839.html
SCRIPT_PATH=$( dirname $( lsof -p $$ | grep 'REG' | grep -oE "/.*$(basename $0)$" ) )
SCRIPT_DATA_FILES="$SCRIPT_PATH/rbxi-data/"
SCRIPT_VERSION_NUMBER=$( grep -im 1 'version:' $SCRIPT_PATH/$SCRIPT_NAME | awk '{print $3}' )
SCRIPT_DOWNLOAD='http://rbxi.googlecode.com/svn/trunk/'
SCRIPT_DOWNLOAD_BRANCH_1='http://rbxi.googlecode.com/svn/branches/one/'
SCRIPT_DOWNLOAD_BRANCH_2='http://rbxi.googlecode.com/svn/branches/two/'
SCRIPT_DOWNLOAD_DEV='http://techpatterns.com/downloads/scripts/'

#### EXCLUDE LIST FILE NAMES
# NOTE: can be a blank file, but most be located in same directory as rbxi
# if you want them in a different directory, use absolute system paths.
EXCLUDE_LIST='root-excludes.txt'
EXCLUDE_HOME_LIST='home-excludes.txt'

#### INITIALIZE VARIABLES TO BE SET ELSEWHERE
USER_HOME_BACKUP_LOCATION=''
ROOT_BACKUP_LOCATION=''

# these are optional, only used if BU_DATA_2 and BU_DATA_1 are set
USER_DATA_1_BACKUP_LOCATION=''
USER_DATA_2_BACKUP_LOCATION=''

# set default value
# default to 1 just because...
BU_NU=1

ENDING_1='...'
ENDING_2='...'
DELETION_TEXT=''

# these are for options, used in case of cron or option run backups/deletes
B_TESTING_1=''
B_TESTING_2=''
DO_BACKUP=''
DELETE_BACKUP=''
SPINNING_WHEEL=''
SKIP_MOUNT=''

# spinning wheel pid value
GET_PID=''

# for timer function
START_TIME=$( date +%s )

## add in user variable values, sticky value file
if [ -f "$SCRIPT_DATA_FILES$SCRIPT_VALUES" ];then
	source $SCRIPT_DATA_FILES$SCRIPT_VALUES
else
	echo "${W}User Values File $SCRIPT_DATA_FILES$SCRIPT_VALUES is missing. Exiting now.${N}"
	exit 1
fi

###################################################################
#####  Functions
###################################################################

#### -------------------------------------------------------------------
#### Utilities
#### -------------------------------------------------------------------

# Error handling
# args: $1 - error number; $2 - optional, extra information
error_handler()
{
	local error_message=''

	# assemble the error message
	case $1 in
		2)	error_message="The component: MOUNT_BU_DISK failed to successfully complete its task. Error code was: $2"
			;;
		3)	error_message="The component: UNMOUNT_BU_DISK failed to successfully complete its task. Error code was: $2"
			;;
		4)	error_message="You must be logged in as root to run this script."
			;;
		5)	error_message="dependency not met: $2 not found in path"
			;;
		6)	error_message="Your backup partition/directory ${C}$BACKUP_DIRECTORY${E} is not present.\nPlease make sure to create it or mount it up before you proceed."
			;;
		7)	error_message="One of the options you entered in your script parameters: $2\nIs not supported. For supported options, check the help menu: $SCRIPT_NAME -h"
			;;
		8)	error_message="the self-updater failed, wget exited with error: $2.\nYou probably need to be root.\nHint, to make for easy updates without being root, do: chown <user name> $SCRIPT_PATH/$SCRIPT_NAME"
			;;
		9)	error_message="missing the required script directory: $2"
			;;
		10)
			error_message="the alt download url you provided: $2\nappears to be wrong, download aborted. Please note, the url\nneeds to end in /, without $SCRIPT_NAME, like: http://yoursite.com/downloads/"
			;;
		11)
			error_message="unsupported testing option argument: -! $2"
			;;
		12)
			error_message="the svn branch download url: $2\nappears to be empty currently. Make sure there is an actual svn branch version\nactive before you try this again. Check http://code.google.com/p/inxi\nto verify the branch status."
			;;
		*)	error_message="Unknown error number: $1"
			;;
	esac
	# then print it and exit
	echo -e "${W}Error $1: $error_message${N}"
	exit $1
}

print_usage()
{
	if [ "$1" == 'err' ];then
		echo 'You entered an invalid option. Please use one of the following only:'
	fi
	echo '-b Automatic backup, no questions.'
	echo '-d Automatic backup and delete, no questions.'
	echo "-L Create symbolic link in /usr/local/bin to $SCRIPT_NAME"
	echo '-m Skip the mounting option.'
	echo '-r Override default backup application: use rsync'
	echo '-R Override default backup application: use rdiff-backup'
	echo '-s Show spinning wheel indicator.'
	echo '-U Update script manually from svn server.'
	echo '-v Show script version and last used information.'
	echo '-h This help menu'
	exit 0
}

### this is not in a function because these variables need to be set on startup
# only use b or d, not both together. If you use both your old backups will be deleted.
# args: $1 - $@ - all args
get_options()
{
	local opt=''

	while getopts :bdhLmrRsUv!: opt
	do
		case $opt in
			h)	print_usage
				;;
			b)	DO_BACKUP='true'
				;;
			d)	DELETE_BACKUP='true'
				;;
			L) create_symbolic_link
				exit 0
				;;
			m)	SKIP_MOUNT='true'
				;;
			r)	BACKUP_APP='rsync'
				;;
			R)	BACKUP_APP='rdiff-backup'
				;;
			s)	SPINNING_WHEEL='true'
				ENDING_1=': '
				ENDING_2=', watch the spinning wheel: '
				;;
			U)	script_self_updater "$SCRIPT_DOWNLOAD" 'svn server'
				;;
			v)	print_version_info
				exit 0
				;;
			!)	# test for various supported methods
				case $OPTARG in
					1)	B_TESTING_1='true'
						;;
					2)	B_TESTING_2='true'
						;;
					3)	B_TESTING_1='true'
						B_TESTING_2='true'
						;;
					10) script_self_updater "$SCRIPT_DOWNLOAD_DEV" 'dev server'
						;;
					11)	script_self_updater "$SCRIPT_DOWNLOAD_BRANCH_1" 'svn: branch one server'
						;;
					12)	script_self_updater "$SCRIPT_DOWNLOAD_BRANCH_2" 'svn: branch two server'
						;;
					http*)
						script_self_updater "$OPTARG" 'alt server'
						;;
					*)	error_handler 11 "$OPTARG"
						;;
				esac
				;;
			*)	error_handler 7 "$1"
				;;
		esac
	done
}

## print out version information for -v
print_version_info()
{
	local last_modified=$( grep -im 1 'date:' $SCRIPT_PATH/$SCRIPT_NAME | gawk '{print $3,$4,$5}' )
	local lastBackUpDirectory='Unset'
	local lastBackupDate='Unset'
	local lastBackUpDuration='Unset'

	if [ -f $SCRIPT_CONFIGS ];then
		lastBackUpDirectory=$( grep 'last-backup-directory=' $SCRIPT_CONFIGS | cut -d '=' -f 2 )
		lastBackupDate=$( grep 'last-backup-date=' $SCRIPT_CONFIGS | cut -d '=' -f 2 )
		lastBackupDuration=$( grep 'last-backup-duration=' $SCRIPT_CONFIGS | cut -d '=' -f 2 )
	fi
	echo "$SCRIPT_NAME - the universal, portable, system backup script."
	echo "Version: $SCRIPT_VERSION_NUMBER"
	echo "Script Last Modified: $last_modified"
	echo "Script Location: $SCRIPT_PATH"
	echo "${S}Last Backup Date: $lastBackupDate"
	echo "${S}Last Backup Directory: $lastBackUpDirectory"
	echo "${S}Last Backup Completion Time: $lastBackUpDuration"
	echo ${N}
}

# args: $1 - download url, not including file name; $2 - string to print out
# note that $1 must end in / to properly construct the url path
script_self_updater()
{
	local wget_error=0

	echo "Starting $SCRIPT_NAME self updater."
	echo "Currently running $SCRIPT_NAME version number: $SCRIPT_VERSION_NUMBER"
	echo "Updating $SCRIPT_NAME in $SCRIPT_PATH using $2 as download source..."
	# first test if path is good, need to make sure it's good because we're -O overwriting file
	wget -q --spider $1$SCRIPT_NAME || wget_error=$?
	# then do the actual download
	if [[ $wget_error -eq 0 ]];then
		wget -q -O $SCRIPT_PATH/$SCRIPT_NAME $1$SCRIPT_NAME || wget_error=$?
		if [[ $wget_error -eq 0 ]];then
			SCRIPT_VERSION_NUMBER=$( grep -im 1 'version:' $SCRIPT_PATH/$SCRIPT_NAME | awk '{print $3}' )
			echo "Successfully updated to $2 version: $SCRIPT_VERSION_NUMBER"
			echo "To run the new version, just start $SCRIPT_NAME again."
			exit 0
		fi
	fi
	# now run the error handlers on any wget failure
	if [[ $wget_error -gt 0 ]];then
		if [[ $2 == 'svn server' ]];then
			error_handler 8 "$wget_error"
		elif [[ $2 == 'alt server' ]];then
			error_handler 10 "$1"
		else
			error_handler 12 "$1"
		fi
	fi
}

# creates the spinning wheel if script starts with -s option, and shows completion
function spinning_wheel_activity_indicator()
{
	local completionText=''

	if [ "$1" == 'delete' ];then
		completionText='backup directories removed'
	fi
	if [ "$1" == 'backup' ];then
		completionText="$2 backed up"
	fi

	echo -n ${S}
	# while kill -0 $GET_PID
	while [ -e /proc/$GET_PID ]
	do
		sleep $SLEEP_TIME
		echo -n '|'
		echo -ne "\b"
		sleep $SLEEP_TIME
		echo -n '/'
		echo -ne "\b"
		sleep $SLEEP_TIME
		echo -n '-'
		echo -ne "\b"
		sleep $SLEEP_TIME
		echo -n "\\"
		echo -ne "\b"
	done
	echo -ne "\b $completionText"
	echo ${N}
}

#### -------------------------------------------------------------------
#### basic tests
#### -------------------------------------------------------------------

check_startup_stuff()
{
	check_root
	if [ ! -f $SCRIPT_CONFIGS ];then
		create_etc_configs
	fi
	if [ ! -d $BACKUP_DIRECTORY ];then
		error_handler 9 $BACKUP_DIRECTORY
	fi
}

check_root()
{
	if [ "$( whoami )" != "root" ];then
		error_handler 4
	fi
}

set_path()
{
	local ExDir=$( dirname $0 )

	if [ "$( pwd )" != "$ExDir" -a "$ExDir" != '.' ];then
		cd $ExDir
	fi
}

create_etc_configs()
{
	if [ ! -f $SCRIPT_CONFIGS ];then
		touch $SCRIPT_CONFIGS
		echo 'last-backup-directory=Unset' >> $SCRIPT_CONFIGS
		echo 'last-backup-date=Unset' >> $SCRIPT_CONFIGS
		echo 'last-backup-duration=Unset' >> $SCRIPT_CONFIGS
	fi
}

create_symbolic_link()
{
	cd /usr/local/bin
	local ulbLink="/usr/local/bin/$SCRIPT_NAME"
	local scriptInPath=$( which $SCRIPT_NAME | grep -v "./$SCRIPT_NAME" )


	if [ ! -L $ulbLink -a ! -f $ulbLink -a -z "$scriptInPath" ];then
		check_root
		echo "${S}Creating link now...${N}"
		echo mainPath: $mainPath
		ln -s $SCRIPT_PATH/$SCRIPT_NAME $ulbLink
	else
		echo "${S}$SCRIPT_NAME is already in your system path, or a link to it already exists.${N}"
	fi
}

#### -------------------------------------------------------------------
#### primary backup tools
#### -------------------------------------------------------------------

set_run_backup()
{
	local opt='' options='' doTheBackup='' removeBackup='' repeat=''
	local lastBackUpDirectory=$( grep 'last-backup-directory=' $SCRIPT_CONFIGS | cut -d '=' -f 2 )
	local lastBackupDate=$( grep 'last-backup-date=' $SCRIPT_CONFIGS | cut -d '=' -f 2 )
	local lastBackupDuration=$( grep 'last-backup-duration=' $SCRIPT_CONFIGS | cut -d '=' -f 2 )

	echo $MLINE
	echo "${S}Last Backup Date: $lastBackupDate"
	echo "${S}Last Backup Directory: $lastBackUpDirectory"
	echo "${S}Last Backup Completion Time: $lastBackUpDuration"
	echo $MLINE
	echo "${S}Backups use standard $BACKUP_APP settings, which lets you restore from any time"
	echo "period stored in the full backup. After first full backup, the next ones will be"
	echo "incremental backups, which run much faster since they only backup changed files."
	echo $LINE
	echo "${S}Please select one of the following numbers to assign the correct backup option."
	echo "1 - backs up as usual with $BACKUP_APP. Does not remove old backups."
	echo "2 - backs up but first deletes old backups. This is final, so once you agree to"
	echo "    remove, no restore of older material will be possible. This will delete the"
	echo "    backup that corresponds to the currently active primary backup directory."
	echo
	echo "3 - Quit, don't do the backup after all."
	echo $LINE
	options='backup-normal backup-and-remove-old quit'
	select opt in $options
	do
		case $opt in
			backup-normal)
				doTheBackup='true'
				;;
			backup-and-remove-old)
				removeBackup='true'
				doTheBackup='true'
				;;
			quit)
				echo "${S}Ok, no backup today, exiting the script...${N}"
				unmount_backup_disk
				exit 0
				;;
			*)
				echo $ELINE
				echo "${E}You need to type in one of above the numbers!!${N}"
				repeat='true'
				;;
		esac
		break
	done

	if [ "$repeat" == 'true' ];then
		set_run_backup
	fi
	if [ "$removeBackup" == 'true' ];then
		remove_backups
	fi
	if [ "$doTheBackup" == 'true' ];then
		run_backups
	fi
}

# here we assign automatically which of the two backup directories to use
# note, doesn't matter which you do, could be one every 6 months, whatever
# the main trick is that you will know which directory to look in for which
# time period
set_which_backup()
{
	local month=$( date +%m )

	# please note, change to taste, could be swapped monthly, every 6 months, how you prefer.
	# however, this way, if you opt to delete your old data very 6 months, that is a very
	# solid backup policy. Obviously, this could use more directory names, 1,2,3,4, if you
	# wanted even more range of backups, for example, a 2 year cycle or whatever.
	if [ $month -le 3 ];then
		BU_NU=2
	elif [ $month -le 6 ];then
		BU_NU=1
	elif [ $month -le 9 ];then
		BU_NU=2
	elif [ $month -le 12 ];then
		BU_NU=1
	fi

	echo $LINE
	echo "${S}Your backup for month ${C}$month${S} will go to this backup location: "${C}$BACKUP_LOCATION$BU_NU${N}

	# make sure it exists
	if [ ! -d "$BACKUP_LOCATION$BU_NU" ];then
		mkdir $BACKUP_LOCATION$BU_NU
	fi

	# NOTE: $BU_NU will have the value 1 or 2 in this case
	if [ "$BU_HOME" != '' ];then
		USER_HOME_BACKUP_LOCATION=$BACKUP_LOCATION$BU_NU/$BU_HOME
	fi
	if [ "$BU_ROOT" != '' ];then
		ROOT_BACKUP_LOCATION=$BACKUP_LOCATION$BU_NU/$BU_ROOT
	fi
	if [ "$BU_DATA_1" != '' ];then
		USER_DATA_1_BACKUP_LOCATION=$BACKUP_LOCATION$BU_NU/$BU_DATA_1
	fi
	if [ "$BU_DATA_2" != '' ];then
		USER_DATA_2_BACKUP_LOCATION=$BACKUP_LOCATION$BU_NU/$BU_DATA_2
	fi
}

remove_backups()
{
	local options='' opt='' repeat='' deleteBackup=''

	echo $LINE
	echo "${Q}Are you sure you want to delete the contents of your backup directories?${N}"
	echo "${S}[Type in the appropriate number and hit enter]"
	echo $LINE
	options='yes-delete no-keep quit'
	select opt in $options
	do
		case $opt in
			yes-delete)
				deleteBackup='true'
				;;
			no-keep)
				echo $LINE
				echo "${S}Ok, no deleting of them today."
				echo
				echo "Continuing with backup now...${N}"
				;;
			quit)
				echo "${S}Ok, no backup today, exiting the script...${N}"
				unmount_backup_disk
				exit 0
				;;
			*)
				echo $ELINE
				echo "${E}You need to type in one of above the numbers!!${N}"
				repeat='true'
				;;
		esac
		break
	done

	if [ "$repeat" == 'true' ];then
		remove_backups
	fi
	if [ "$deleteBackup" == 'true' ];then
		delete_old_backup
	fi
}

delete_old_backup()
{
	local removedDirectories=$( ls $BACKUP_LOCATION$BU_NU )  directory=''
	GET_PID=''

	echo $LINE
	echo -n "${S}Deleting "
	for directory in $removedDirectories
	do
		echo -n "${C}$directory${S} "
	done
	echo -n "in ${C}$BACKUP_LOCATION$BU_NU${N}"
	echo
	echo -n "${S}This could take a while, be patient$ENDING_2${N}"
	if [ "$SPINNING_WHEEL" == 'true' ];then
		rm -fr $BACKUP_LOCATION$BU_NU/* &
		GET_PID="$!"
		spinning_wheel_activity_indicator delete
		wait
	else
		rm -fr $BACKUP_LOCATION$BU_NU/*
		echo "${S}Backup directories removed."
	fi
	DELETION_TEXT=' deletion and'
	echo
	echo "Starting backup now${N}"
}

run_backups()
{
	# If you don't need excludes in /home, then just delete the exclude stuff, --exclude...
	echo $LINE

	#backup home directory
	# backup optional user data 1
	if [ "$BU_HOME" != '' ];then
		echo -n "${S}Backing up ${C}home${S} directory$ENDING_1${N}"
		if [ "$SPINNING_WHEEL" == 'true' ];then
			GET_PID=''
			rdiff-backup --exclude-globbing-filelist $SCRIPT_DATA_FILES$EXCLUDE_HOME_LIST $USER_HOME_PARENT $USER_HOME_BACKUP_LOCATION &
			GET_PID="$!"
			spinning_wheel_activity_indicator backup home
		else
			rdiff-backup --exclude-globbing-filelist $SCRIPT_DATA_FILES$EXCLUDE_HOME_LIST $USER_HOME_PARENT $USER_HOME_BACKUP_LOCATION
			echo
		fi
	fi

	# backup optional user data 1
	if [ "$BU_DATA_1" != '' ];then
		echo -n "${S}Backing up${C}$USER_DATA_1_DESC${S} directory$ENDING_1${N}"
		if [ "$SPINNING_WHEEL" == 'true' ];then
			GET_PID=''
			rdiff-backup $USER_DATA_1 $USER_DATA_1_BACKUP_LOCATION &
			GET_PID="$!"
			spinning_wheel_activity_indicator backup $USER_DATA_1_DESC
		else
			rdiff-backup $USER_DATA_1 $USER_DATA_1_BACKUP_LOCATION
			echo
		fi
	fi

	# backup optional user data 2
	if [ "$BU_DATA_2" != '' ];then
		echo -n "${S}Backing up${C}$USER_DATA_2_DESC${S} directory$ENDING_1${N}"
		if [ "$SPINNING_WHEEL" == 'true' ];then
			GET_PID=''
			rdiff-backup $USER_DATA_2 $USER_DATA_2_BACKUP_LOCATION &
			GET_PID="$!"
			spinning_wheel_activity_indicator backup $USER_DATA_2_DESC
		else
			rdiff-backup $USER_DATA_2 $USER_DATA_2_BACKUP_LOCATION
			echo
		fi
	fi

	# backup system root directory
	# http://www.mail-archive.com/rdiff-backup-users@nongnu.org/msg01212.html
	# --exclude-sockets to get rid of that dumb socket error
	# backup optional user data 1
	if [ "$BU_ROOT" != '' ];then
		echo -n "${S}Backing up ${C}root${S} directory ${C}$ROOT_PARTITION${S}$ENDING_1${N}"
		if [ "$SPINNING_WHEEL" == 'true' ];then
			GET_PID=''
			rdiff-backup --exclude-sockets --exclude-globbing-filelist $SCRIPT_DATA_FILES$EXCLUDE_LIST $SYSTEM_ROOT $ROOT_BACKUP_LOCATION &
			GET_PID="$!"
			spinning_wheel_activity_indicator backup $ROOT_PARTITION
		else
			rdiff-backup --exclude-sockets --exclude-globbing-filelist $SCRIPT_DATA_FILES$EXCLUDE_LIST $SYSTEM_ROOT $ROOT_BACKUP_LOCATION
			echo
		fi
	fi
	finish_backup
}

finish_backup()
{
	update_configs
	print_the_end_time
	unmount_backup_disk
	print_complete_message
}

update_configs()
{
	local backupDate=$( date +"%e %B %Y - %R" )

	echo $LINE
	echo "${S}Updating backup records now...${N}"
	sed -ir "s%last-backup-directory=.*%last-backup-directory=$BACKUP_LOCATION$BU_NU%" $SCRIPT_CONFIGS
	sed -ir "s/last-backup-date=.*/last-backup-date=$backupDate/" $SCRIPT_CONFIGS
}

# do some arithmetic on time
print_the_end_time()
{
	local endTime=$( date +%s )
	local completedTime=$(( $endTime - $START_TIME ))
	local hours=$(( $completedTime / 3600 ))
	local remainingMinutes=$(( $completedTime % 3600 ))
	local minutes=$(( $remainingMinutes / 60 ))
	local seconds=$(( $remainingMinutes % 60 ))
	local hourText='' minuteText='' secondText='' plural=''

	# set hours, if needed
	if [ "$hours" -ne 0 ];then
		if [ "$hours" -gt 1 ];then
			plural='s'
		else
			plural=''
		fi
		hourText=" ${C}$hours${S} hour$plural,"
	fi

	# set minutes
	if [ "$minutes" -gt 1 -o "$minutes" -eq 0 ];then
		plural='s'
	else
		plural=''
	fi
	minuteText=" ${C}$minutes${S} minute$plural,"

	# set seconds
	if [ "$seconds" -gt 1 -o "$seconds" -eq 0 ];then
		plural='s'
	else
		plural=''
	fi
	secondText=" ${C}$seconds${S} second$plural"

	echo "${S}The$DELETION_TEXT backup took$hourText$minuteText$secondText to complete.${N}"
	# zero pad the data
	minutes=$( printf %02d $minutes )
	seconds=$( printf %02d $seconds )
	sed -ir "s/last-backup-duration=.*/last-backup-duration=$hours:$minutes:$seconds/" $SCRIPT_CONFIGS
}

unmount_backup_disk()
{
	if [ "$MOUNT_BU_DISK" != '' -a "$SKIP_MOUNT" != 'true' ];then
		echo -n "${S}Unmounting your backup partition $BACKUP_DIRECTORY now...${N}"
		eval $UNMOUNT_BU_DISK || error_handler 3 "$?"
		echo "${S}.....successfully unmounted.${N}"
	fi
}

mount_backup_disk()
{
	if [ "$MOUNT_BU_DISK" != '' -a "$SKIP_MOUNT" != 'true'  ];then
		echo -n "${S}Mounting your backup drive/partition to $BACKUP_DIRECTORY now...${N}"
		eval $MOUNT_BU_DISK || error_handler 2 "$?"
		echo "${S}.....successfully mounted.${N}"
	fi
}

print_complete_message()
{
	echo $MLINE
	echo "${M}Ok, all done backing up for today"
	echo $MLINE
}

###################################################################
#####   EXECUTE SCRIPT COMPONENTS
###################################################################
get_options "$@"
# Make sure user is logged in as root first and that backup location is present
check_startup_stuff
# this sets the correct startup path so that exclude lists load correctly
set_path
# then, if you use this, mount your backup drive
mount_backup_disk

# initialize the backup directory values, based on month of year
set_which_backup

# for option run deletion
if [ "$DELETE_BACKUP" == 'true' ];then
	delete_old_backup
fi
if [ "$DO_BACKUP" == 'true' -o "$DELETE_BACKUP" == 'true' ];then
	run_backups
else
	set_run_backup
fi

## extra information:

#SpecialFileError var/run/acpid.socket Socket error: AF_UNIX path too long
#SpecialFileError var/run/dbus/system_bus_socket Socket error: AF_UNIX path too long
#SpecialFileError var/run/dirmngr/socket Socket error: AF_UNIX path too long
#SpecialFileError var/run/mysqld/mysqld.sock Socket error: AF_UNIX path too long
#SpecialFileError var/run/pcscd.comm Socket error: AF_UNIX path too long
#SpecialFileError var/run/xdmctl/dmctl/socket Socket error: AF_UNIX path too long
#SpecialFileError var/run/xdmctl/dmctl-:0/socket Socket error: AF_UNIX path too long

exit 0
###**EOF**###